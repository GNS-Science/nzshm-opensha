diff --git a/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/MFDManipulation.java b/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/MFDManipulation.java
index 8b14f3d..dd29148 100644
--- a/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/MFDManipulation.java
+++ b/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/MFDManipulation.java
@@ -8,8 +8,7 @@ import org.opensha.commons.data.function.EvenlyDiscretizedFunc;
 import org.opensha.commons.data.uncertainty.UncertainIncrMagFreqDist;
 import org.opensha.sha.magdist.IncrementalMagFreqDist;
 
-public class
-MFDManipulation {
+public class MFDManipulation {
 
     public static final double FIRST_WEIGHT_POWER_MAG = 7.0;
 
diff --git a/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/NZSHM22_CrustalInversionConfiguration.java b/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/NZSHM22_CrustalInversionConfiguration.java
index 1ea01d8..50b651a 100644
--- a/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/NZSHM22_CrustalInversionConfiguration.java
+++ b/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/NZSHM22_CrustalInversionConfiguration.java
@@ -1,249 +1,249 @@
-package nz.cri.gns.NZSHM22.opensha.inversion;
-
-import com.google.common.base.Preconditions;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.function.IntPredicate;
-import nz.cri.gns.NZSHM22.opensha.enumTreeBranches.NZSHM22_LogicTreeBranch;
-import nz.cri.gns.NZSHM22.opensha.enumTreeBranches.NZSHM22_Regions;
-import org.opensha.commons.geo.GriddedRegion;
-import org.opensha.sha.magdist.IncrementalMagFreqDist;
-import scratch.UCERF3.enumTreeBranches.InversionModels;
-
-/**
- * This represents all of the inversion configuration parameters specific to an individual model on
- * the NZSHM22 logic tree.
- *
- * <p>based on scratch.UCERF3.inversion.UCERF3InversionConfiguration
- *
- * @author chrisbc
- */
-public class NZSHM22_CrustalInversionConfiguration extends AbstractInversionConfiguration {
-
-    protected static final boolean D = true; // for debugging
-    private double paleoRateConstraintWt;
-    private double mfdSmoothnessConstraintWtForPaleoParents;
-
-    /** */
-    public NZSHM22_CrustalInversionConfiguration() {}
-
-    public static final double DEFAULT_MFD_EQUALITY_WT = 10;
-    public static final double DEFAULT_MFD_INEQUALITY_WT = 1000;
-
-    public static void setRegionalData(
-            NZSHM22_InversionFaultSystemRuptSet rupSet, double mMin_Sans, double mMin_TVZ) {
-
-        NZSHM22_LogicTreeBranch branch = rupSet.getModule(NZSHM22_LogicTreeBranch.class);
-        NZSHM22_Regions regions = branch.getValue(NZSHM22_Regions.class);
-
-        GriddedRegion tvzRegion = regions.getTvzRegion();
-        GriddedRegion sansTvzRegion = regions.getSansTvzRegion();
-
-        TvzDomainSections tvzSections = rupSet.getModule(TvzDomainSections.class);
-        IntPredicate tvzFilter = tvzSections::isInRegion;
-
-        RegionalRupSetData tvz = new RegionalRupSetData(rupSet, tvzRegion, tvzFilter, mMin_TVZ);
-        RegionalRupSetData sansTvz =
-                new RegionalRupSetData(rupSet, sansTvzRegion, tvzFilter.negate(), mMin_Sans);
-
-        rupSet.setRegionalData(tvz, sansTvz);
-    }
-
-    /**
-     * This generates an inversion configuration for the given inversion model and rupture set
-     *
-     * @param model
-     * @param rupSet
-     * @param mfdEqualityConstraintWt weight of magnitude-distribution EQUALITY constraint relative
-     *     to slip-rate constraint (recommended: 10)
-     * @param mfdInequalityConstraintWt weight of magnitude-distribution INEQUALITY constraint
-     *     relative to slip-rate constraint (recommended: 1000)
-     * @param totalRateM5_Sans
-     * @param totalRateM5_TVZ
-     * @param bValue_Sans
-     * @param bValue_TVZ
-     * @param mfdTransitionMag
-     * @param mfdUncertWtdConstraintScalar TODO
-     * @return
-     */
-    public static NZSHM22_CrustalInversionConfiguration forModel(
-            InversionModels model,
-            NZSHM22_InversionFaultSystemRuptSet rupSet,
-            double[] initialSolution,
-            double mfdEqualityConstraintWt,
-            double mfdInequalityConstraintWt,
-            double totalRateM5_Sans,
-            double totalRateM5_TVZ,
-            double bValue_Sans,
-            double bValue_TVZ,
-            double mfdTransitionMag,
-            double mMin_Sans,
-            double mMin_TVZ,
-            double maxMagSans,
-            double maxMagTVZ,
-            double mfdUncertWtdConstraintWt,
-            double mfdUncertWtdConstraintPower,
-            double mfdUncertWtdConstraintScalar,
-            boolean excludeMinMag) {
-
-        /*
-         * ******************************************* COMMON TO ALL MODELS
-         * *******************************************
-         */
-        // Setting slip-rate constraint weights to 0 does not disable them! To disable
-        // one or the other (both cannot be), use slipConstraintRateWeightingType Below
-        double slipRateConstraintWt_normalized =
-                1; // For SlipRateConstraintWeightingType.NORMALIZED (also used for
-        // SlipRateConstraintWeightingType.BOTH) -- NOT USED if
-        // UNNORMALIZED!
-        double slipRateConstraintWt_unnormalized =
-                100; // For SlipRateConstraintWeightingType.UNNORMALIZED (also used
-        // for SlipRateConstraintWeightingType.BOTH) -- NOT USED if
-        // NORMALIZED!
-        // If normalized, slip rate misfit is % difference for each section (recommended
-        // since it helps fit slow-moving faults). If unnormalized, misfit is absolute
-        // difference.
-        // BOTH includes both normalized and unnormalized constraints.
-        NZSlipRateConstraintWeightingType slipRateWeighting =
-                NZSlipRateConstraintWeightingType.BOTH; // (recommended: BOTH)
-
-        // weight of rupture-rate minimization constraint weights relative to slip-rate
-        // constraint (recommended: 10,000)
-        // (currently used to minimization rates of rups below sectMinMag)
-        double minimizationConstraintWt = 10000;
-
-        //		/* *******************************************
-        //		 * MODEL SPECIFIC
-        //		 * ******************************************* */
-        //		// fraction of the minimum rupture rate basis to be used as initial rates
-        double minimumRuptureRateFraction = 0;
-
-        double[] initialRupModel = null;
-        double[] minimumRuptureRateBasis = null;
-
-        setRegionalData(rupSet, mMin_Sans, mMin_TVZ);
-
-        // setup MFD constraints
-        NZSHM22_CrustalInversionTargetMFDs inversionMFDs =
-                new NZSHM22_CrustalInversionTargetMFDs(
-                        rupSet,
-                        totalRateM5_Sans,
-                        totalRateM5_TVZ,
-                        bValue_Sans,
-                        bValue_TVZ,
-                        mMin_Sans,
-                        mMin_TVZ,
-                        maxMagSans,
-                        maxMagTVZ,
-                        mfdUncertWtdConstraintPower,
-                        mfdUncertWtdConstraintScalar);
-        rupSet.setInversionTargetMFDs(inversionMFDs);
-        List<IncrementalMagFreqDist> mfdConstraints = inversionMFDs.getMFD_Constraints();
-
-        if (model.isConstrained()) {
-            // CONSTRAINED BRANCHES
-            if (model == InversionModels.CHAR_CONSTRAINED) {
-                // For water level
-                minimumRuptureRateFraction = 0.0;
-
-                // >>				minimumRuptureRateBasis = UCERF3InversionConfiguration.adjustStartingModel(
-                // >>						UCERF3InversionConfiguration.getSmoothStartingSolution(rupSet,
-                // targetOnFaultMFD),
-                // >>						mfdConstraints, rupSet, true);
-
-                //				initialRupModel = adjustIsolatedSections(rupSet, initialRupModel);
-                //				if (mfdInequalityConstraintWt>0.0 || mfdEqualityConstraintWt>0.0)
-                // initialRupModel = adjustStartingModel(initialRupModel, mfdConstraints, rupSet,
-                // true);
-
-                //				initialRupModel = removeRupsBelowMinMag(rupSet, initialRupModel);
-                if (initialSolution != null) {
-                    Preconditions.checkArgument(
-                            rupSet.getNumRuptures() == initialSolution.length,
-                            "Initial solution is for the wrong number of ruptures.");
-                    initialRupModel = initialSolution;
-                } else {
-                    initialRupModel = new double[rupSet.getNumRuptures()];
-                }
-            } else throw new IllegalStateException("Unknown inversion model: " + model);
-        }
-
-        /* end MODIFIERS */
-
-        List<IncrementalMagFreqDist> mfdInequalityConstraints = new ArrayList<>();
-        List<IncrementalMagFreqDist> mfdEqualityConstraints = new ArrayList<>();
-
-        if (mfdEqualityConstraintWt > 0.0 && mfdInequalityConstraintWt > 0.0) {
-            // we have both MFD constraints, apply a transition mag from equality to
-            // inequality
-
-            mfdEqualityConstraints =
-                    MFDManipulation.restrictMFDConstraintMagRange(
-                            mfdConstraints, mfdConstraints.get(0).getMinX(), mfdTransitionMag);
-            mfdInequalityConstraints =
-                    MFDManipulation.restrictMFDConstraintMagRange(
-                            mfdConstraints, mfdTransitionMag, mfdConstraints.get(0).getMaxX());
-        } else if (mfdEqualityConstraintWt > 0.0) {
-            mfdEqualityConstraints = mfdConstraints;
-        } else if (mfdInequalityConstraintWt > 0.0) {
-            mfdInequalityConstraints = mfdConstraints;
-        } else {
-            // no MFD constraints, do nothing
-        }
-
-        // NSHM-style config using setter methods...
-        NZSHM22_CrustalInversionConfiguration newConfig =
-                (NZSHM22_CrustalInversionConfiguration)
-                        new NZSHM22_CrustalInversionConfiguration()
-                                .setInversionTargetMfds(inversionMFDs)
-                                // MFD config
-                                .setMagnitudeEqualityConstraintWt(mfdEqualityConstraintWt)
-                                .setMagnitudeInequalityConstraintWt(mfdInequalityConstraintWt)
-                                // Slip Rate config
-                                .setSlipRateConstraintWt_normalized(slipRateConstraintWt_normalized)
-                                .setSlipRateConstraintWt_unnormalized(
-                                        slipRateConstraintWt_unnormalized)
-                                .setSlipRateWeightingType(slipRateWeighting)
-                                .setMfdEqualityConstraints(mfdEqualityConstraints)
-                                .setMfdInequalityConstraints(mfdInequalityConstraints)
-                                // Rate Minimization config
-                                .setMinimumRuptureRateFraction(minimumRuptureRateFraction)
-                                .setMinimumRuptureRateBasis(minimumRuptureRateBasis)
-                                .setInitialRupModel(initialRupModel);
-
-        // ExcludeMinMag is handled in the runner. if that's used, do not use old-fashioned
-        // constraint
-        if (!excludeMinMag) {
-            newConfig.setMinimizationConstraintWt(minimizationConstraintWt);
-        }
-
-        if (mfdUncertWtdConstraintWt > 0.0) {
-            newConfig
-                    .setMagnitudeUncertaintyWeightedConstraintWt(mfdUncertWtdConstraintWt)
-                    .setMfdUncertaintyWeightedConstraints(
-                            inversionMFDs.getMfdUncertaintyConstraints());
-        }
-
-        return newConfig;
-    }
-
-    public NZSHM22_CrustalInversionConfiguration setPaleoRateConstraintWt(
-            double paleoRateConstraintWt) {
-        this.paleoRateConstraintWt = paleoRateConstraintWt;
-        return this;
-    }
-
-    public double getPaleoRateConstraintWt() {
-        return paleoRateConstraintWt;
-    }
-
-    public NZSHM22_CrustalInversionConfiguration setpaleoParentRateSmoothnessConstraintWeight(
-            double paleoParentRateSmoothnessConstraintWeight) {
-        this.mfdSmoothnessConstraintWtForPaleoParents = paleoParentRateSmoothnessConstraintWeight;
-        return this;
-    }
-
-    public double getpaleoParentRateSmoothnessConstraintWeight() {
-        return mfdSmoothnessConstraintWtForPaleoParents;
-    }
-}
+package nz.cri.gns.NZSHM22.opensha.inversion;
+
+import com.google.common.base.Preconditions;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.IntPredicate;
+import nz.cri.gns.NZSHM22.opensha.enumTreeBranches.NZSHM22_LogicTreeBranch;
+import nz.cri.gns.NZSHM22.opensha.enumTreeBranches.NZSHM22_Regions;
+import org.opensha.commons.geo.GriddedRegion;
+import org.opensha.sha.magdist.IncrementalMagFreqDist;
+import scratch.UCERF3.enumTreeBranches.InversionModels;
+
+/**
+ * This represents all of the inversion configuration parameters specific to an individual model on
+ * the NZSHM22 logic tree.
+ *
+ * <p>based on scratch.UCERF3.inversion.UCERF3InversionConfiguration
+ *
+ * @author chrisbc
+ */
+public class NZSHM22_CrustalInversionConfiguration extends AbstractInversionConfiguration {
+
+    protected static final boolean D = true; // for debugging
+    private double paleoRateConstraintWt;
+    private double mfdSmoothnessConstraintWtForPaleoParents;
+
+    /** */
+    public NZSHM22_CrustalInversionConfiguration() {}
+
+    public static final double DEFAULT_MFD_EQUALITY_WT = 10;
+    public static final double DEFAULT_MFD_INEQUALITY_WT = 1000;
+
+    public static void setRegionalData(
+            NZSHM22_InversionFaultSystemRuptSet rupSet, double mMin_Sans, double mMin_TVZ) {
+
+        NZSHM22_LogicTreeBranch branch = rupSet.getModule(NZSHM22_LogicTreeBranch.class);
+        NZSHM22_Regions regions = branch.getValue(NZSHM22_Regions.class);
+
+        GriddedRegion tvzRegion = regions.getTvzRegion();
+        GriddedRegion sansTvzRegion = regions.getSansTvzRegion();
+
+        TvzDomainSections tvzSections = rupSet.getModule(TvzDomainSections.class);
+        IntPredicate tvzFilter = tvzSections::isInRegion;
+
+        RegionalRupSetData tvz = new RegionalRupSetData(rupSet, tvzRegion, tvzFilter, mMin_TVZ);
+        RegionalRupSetData sansTvz =
+                new RegionalRupSetData(rupSet, sansTvzRegion, tvzFilter.negate(), mMin_Sans);
+
+        rupSet.setRegionalData(tvz, sansTvz);
+    }
+
+    /**
+     * This generates an inversion configuration for the given inversion model and rupture set
+     *
+     * @param model
+     * @param rupSet
+     * @param mfdEqualityConstraintWt weight of magnitude-distribution EQUALITY constraint relative
+     *     to slip-rate constraint (recommended: 10)
+     * @param mfdInequalityConstraintWt weight of magnitude-distribution INEQUALITY constraint
+     *     relative to slip-rate constraint (recommended: 1000)
+     * @param totalRateM5_Sans
+     * @param totalRateM5_TVZ
+     * @param bValue_Sans
+     * @param bValue_TVZ
+     * @param mfdTransitionMag
+     * @param mfdUncertWtdConstraintScalar TODO
+     * @return
+     */
+    public static NZSHM22_CrustalInversionConfiguration forModel(
+            InversionModels model,
+            NZSHM22_InversionFaultSystemRuptSet rupSet,
+            double[] initialSolution,
+            double mfdEqualityConstraintWt,
+            double mfdInequalityConstraintWt,
+            double totalRateM5_Sans,
+            double totalRateM5_TVZ,
+            double bValue_Sans,
+            double bValue_TVZ,
+            double mfdTransitionMag,
+            double mMin_Sans,
+            double mMin_TVZ,
+            double maxMagSans,
+            double maxMagTVZ,
+            double mfdUncertWtdConstraintWt,
+            double mfdUncertWtdConstraintPower,
+            double mfdUncertWtdConstraintScalar,
+            boolean excludeMinMag) {
+
+        /*
+         * ******************************************* COMMON TO ALL MODELS
+         * *******************************************
+         */
+        // Setting slip-rate constraint weights to 0 does not disable them! To disable
+        // one or the other (both cannot be), use slipConstraintRateWeightingType Below
+        double slipRateConstraintWt_normalized =
+                1; // For SlipRateConstraintWeightingType.NORMALIZED (also used for
+        // SlipRateConstraintWeightingType.BOTH) -- NOT USED if
+        // UNNORMALIZED!
+        double slipRateConstraintWt_unnormalized =
+                100; // For SlipRateConstraintWeightingType.UNNORMALIZED (also used
+        // for SlipRateConstraintWeightingType.BOTH) -- NOT USED if
+        // NORMALIZED!
+        // If normalized, slip rate misfit is % difference for each section (recommended
+        // since it helps fit slow-moving faults). If unnormalized, misfit is absolute
+        // difference.
+        // BOTH includes both normalized and unnormalized constraints.
+        NZSlipRateConstraintWeightingType slipRateWeighting =
+                NZSlipRateConstraintWeightingType.BOTH; // (recommended: BOTH)
+
+        // weight of rupture-rate minimization constraint weights relative to slip-rate
+        // constraint (recommended: 10,000)
+        // (currently used to minimization rates of rups below sectMinMag)
+        double minimizationConstraintWt = 10000;
+
+        //		/* *******************************************
+        //		 * MODEL SPECIFIC
+        //		 * ******************************************* */
+        //		// fraction of the minimum rupture rate basis to be used as initial rates
+        double minimumRuptureRateFraction = 0;
+
+        double[] initialRupModel = null;
+        double[] minimumRuptureRateBasis = null;
+
+        setRegionalData(rupSet, mMin_Sans, mMin_TVZ);
+
+        // setup MFD constraints
+        NZSHM22_CrustalInversionTargetMFDs inversionMFDs =
+                new NZSHM22_CrustalInversionTargetMFDs(
+                        rupSet,
+                        totalRateM5_Sans,
+                        totalRateM5_TVZ,
+                        bValue_Sans,
+                        bValue_TVZ,
+                        mMin_Sans,
+                        mMin_TVZ,
+                        maxMagSans,
+                        maxMagTVZ,
+                        mfdUncertWtdConstraintPower,
+                        mfdUncertWtdConstraintScalar);
+        rupSet.setInversionTargetMFDs(inversionMFDs);
+        List<IncrementalMagFreqDist> mfdConstraints = inversionMFDs.getMFD_Constraints();
+
+        if (model.isConstrained()) {
+            // CONSTRAINED BRANCHES
+            if (model == InversionModels.CHAR_CONSTRAINED) {
+                // For water level
+                minimumRuptureRateFraction = 0.0;
+
+                // >>				minimumRuptureRateBasis = UCERF3InversionConfiguration.adjustStartingModel(
+                // >>						UCERF3InversionConfiguration.getSmoothStartingSolution(rupSet,
+                // targetOnFaultMFD),
+                // >>						mfdConstraints, rupSet, true);
+
+                //				initialRupModel = adjustIsolatedSections(rupSet, initialRupModel);
+                //				if (mfdInequalityConstraintWt>0.0 || mfdEqualityConstraintWt>0.0)
+                // initialRupModel = adjustStartingModel(initialRupModel, mfdConstraints, rupSet,
+                // true);
+
+                //				initialRupModel = removeRupsBelowMinMag(rupSet, initialRupModel);
+                if (initialSolution != null) {
+                    Preconditions.checkArgument(
+                            rupSet.getNumRuptures() == initialSolution.length,
+                            "Initial solution is for the wrong number of ruptures.");
+                    initialRupModel = initialSolution;
+                } else {
+                    initialRupModel = new double[rupSet.getNumRuptures()];
+                }
+            } else throw new IllegalStateException("Unknown inversion model: " + model);
+        }
+
+        /* end MODIFIERS */
+
+        List<IncrementalMagFreqDist> mfdInequalityConstraints = new ArrayList<>();
+        List<IncrementalMagFreqDist> mfdEqualityConstraints = new ArrayList<>();
+
+        if (mfdEqualityConstraintWt > 0.0 && mfdInequalityConstraintWt > 0.0) {
+            // we have both MFD constraints, apply a transition mag from equality to
+            // inequality
+
+            mfdEqualityConstraints =
+                    MFDManipulation.restrictMFDConstraintMagRange(
+                            mfdConstraints, mfdConstraints.get(0).getMinX(), mfdTransitionMag);
+            mfdInequalityConstraints =
+                    MFDManipulation.restrictMFDConstraintMagRange(
+                            mfdConstraints, mfdTransitionMag, mfdConstraints.get(0).getMaxX());
+        } else if (mfdEqualityConstraintWt > 0.0) {
+            mfdEqualityConstraints = mfdConstraints;
+        } else if (mfdInequalityConstraintWt > 0.0) {
+            mfdInequalityConstraints = mfdConstraints;
+        } else {
+            // no MFD constraints, do nothing
+        }
+
+        // NSHM-style config using setter methods...
+        NZSHM22_CrustalInversionConfiguration newConfig =
+                (NZSHM22_CrustalInversionConfiguration)
+                        new NZSHM22_CrustalInversionConfiguration()
+                                .setInversionTargetMfds(inversionMFDs)
+                                // MFD config
+                                .setMagnitudeEqualityConstraintWt(mfdEqualityConstraintWt)
+                                .setMagnitudeInequalityConstraintWt(mfdInequalityConstraintWt)
+                                // Slip Rate config
+                                .setSlipRateConstraintWt_normalized(slipRateConstraintWt_normalized)
+                                .setSlipRateConstraintWt_unnormalized(
+                                        slipRateConstraintWt_unnormalized)
+                                .setSlipRateWeightingType(slipRateWeighting)
+                                .setMfdEqualityConstraints(mfdEqualityConstraints)
+                                .setMfdInequalityConstraints(mfdInequalityConstraints)
+                                // Rate Minimization config
+                                .setMinimumRuptureRateFraction(minimumRuptureRateFraction)
+                                .setMinimumRuptureRateBasis(minimumRuptureRateBasis)
+                                .setInitialRupModel(initialRupModel);
+
+        // ExcludeMinMag is handled in the runner. if that's used, do not use old-fashioned
+        // constraint
+        if (!excludeMinMag) {
+            newConfig.setMinimizationConstraintWt(minimizationConstraintWt);
+        }
+
+        if (mfdUncertWtdConstraintWt > 0.0) {
+            newConfig
+                    .setMagnitudeUncertaintyWeightedConstraintWt(mfdUncertWtdConstraintWt)
+                    .setMfdUncertaintyWeightedConstraints(
+                            inversionMFDs.getMfdUncertaintyConstraints());
+        }
+
+        return newConfig;
+    }
+
+    public NZSHM22_CrustalInversionConfiguration setPaleoRateConstraintWt(
+            double paleoRateConstraintWt) {
+        this.paleoRateConstraintWt = paleoRateConstraintWt;
+        return this;
+    }
+
+    public double getPaleoRateConstraintWt() {
+        return paleoRateConstraintWt;
+    }
+
+    public NZSHM22_CrustalInversionConfiguration setpaleoParentRateSmoothnessConstraintWeight(
+            double paleoParentRateSmoothnessConstraintWeight) {
+        this.mfdSmoothnessConstraintWtForPaleoParents = paleoParentRateSmoothnessConstraintWeight;
+        return this;
+    }
+
+    public double getpaleoParentRateSmoothnessConstraintWeight() {
+        return mfdSmoothnessConstraintWtForPaleoParents;
+    }
+}
diff --git a/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/NZSHM22_CrustalInversionInputGenerator.java b/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/NZSHM22_CrustalInversionInputGenerator.java
index 296d2b3..21818e1 100644
--- a/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/NZSHM22_CrustalInversionInputGenerator.java
+++ b/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/NZSHM22_CrustalInversionInputGenerator.java
@@ -1,425 +1,425 @@
-package nz.cri.gns.NZSHM22.opensha.inversion;
-
-import com.google.common.base.Preconditions;
-import java.io.IOException;
-import java.util.*;
-import nz.cri.gns.NZSHM22.opensha.analysis.NZSHM22_FaultSystemRupSetCalc;
-import org.opensha.sha.earthquake.faultSysSolution.FaultSystemRupSet;
-import org.opensha.sha.earthquake.faultSysSolution.inversion.InversionInputGenerator;
-import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.ConstraintWeightingType;
-import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.InversionConstraint;
-import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.impl.*;
-import org.opensha.sha.faultSurface.FaultSection;
-import scratch.UCERF3.utils.U3SectionMFD_constraint;
-import scratch.UCERF3.utils.aveSlip.U3AveSlipConstraint;
-import scratch.UCERF3.utils.paleoRateConstraints.UCERF3_PaleoProbabilityModel;
-
-/**
- * This class is used to generate inversion inputs (A/A_ineq matrices, d/d_ineq vectors) for a given
- * rupture set, inversion configuration, paleo rate constraints, improbability constraint, and paleo
- * probability model. It can also save these inputs to a zip file to be run on high performance
- * computing.
- */
-public class NZSHM22_CrustalInversionInputGenerator extends InversionInputGenerator {
-
-    private static final boolean D = false;
-    /**
-     * this enables use of the getQuick and setQuick methods on the sparse matrices. this comes with
-     * a performance boost, but disables range checks and is more prone to errors.
-     */
-    private static final boolean QUICK_GETS_SETS = true;
-
-    // inputs
-    private NZSHM22_InversionFaultSystemRuptSet rupSet;
-    private AbstractInversionConfiguration config;
-    private List<UncertainDataConstraint.SectMappedUncertainDataConstraint> paleoRateConstraints;
-    private List<U3AveSlipConstraint> aveSlipConstraints;
-    private double[] improbabilityConstraint;
-    private PaleoProbabilityModel paleoProbabilityModel;
-
-    public NZSHM22_CrustalInversionInputGenerator(
-            NZSHM22_InversionFaultSystemRuptSet rupSet,
-            NZSHM22_CrustalInversionConfiguration config,
-            List<UncertainDataConstraint.SectMappedUncertainDataConstraint> paleoRateConstraints,
-            List<U3AveSlipConstraint> aveSlipConstraints,
-            double[] improbabilityConstraint, // may become an object in the future
-            PaleoProbabilityModel paleoProbabilityModel) {
-        super(
-                rupSet,
-                buildConstraints(
-                        rupSet,
-                        config,
-                        paleoRateConstraints,
-                        aveSlipConstraints,
-                        paleoProbabilityModel),
-                config.getInitialRupModel(),
-                buildWaterLevel(config, rupSet));
-        this.rupSet = rupSet;
-        this.config = config;
-        this.paleoRateConstraints = paleoRateConstraints;
-        this.improbabilityConstraint = improbabilityConstraint;
-        this.aveSlipConstraints = aveSlipConstraints;
-        this.paleoProbabilityModel = paleoProbabilityModel;
-    }
-
-    private static PaleoProbabilityModel defaultProbModel = null;
-
-    /**
-     * Loads the default paleo probability model for UCERF3 (Glenn's file). Can be turned into an
-     * enum if we get alternatives
-     *
-     * @return
-     * @throws IOException
-     */
-    public static PaleoProbabilityModel loadDefaultPaleoProbabilityModel() throws IOException {
-        if (defaultProbModel == null) defaultProbModel = UCERF3_PaleoProbabilityModel.load();
-        return defaultProbModel;
-    }
-
-    private static List<InversionConstraint> buildConstraints(
-            NZSHM22_InversionFaultSystemRuptSet rupSet,
-            NZSHM22_CrustalInversionConfiguration config,
-            List<UncertainDataConstraint.SectMappedUncertainDataConstraint> paleoRateConstraints,
-            List<U3AveSlipConstraint> aveSlipConstraints,
-            PaleoProbabilityModel paleoProbabilityModel) {
-
-        System.out.println("buildConstraints");
-        System.out.println("================");
-
-        System.out.println(
-                "config.getSlipRateWeightingType(): " + config.getSlipRateWeightingType());
-        if (config.getSlipRateWeightingType()
-                == AbstractInversionConfiguration.NZSlipRateConstraintWeightingType
-                        .NORMALIZED_BY_UNCERTAINTY) {
-            System.out.println(
-                    "config.getSlipRateUncertaintyConstraintWt() :"
-                            + config.getSlipRateUncertaintyConstraintWt());
-            System.out.println(
-                    "config.getSlipRateUncertaintyConstraintScalingFactor() :"
-                            + config.getSlipRateUncertaintyConstraintScalingFactor());
-        } else {
-            System.out.println(
-                    "config.getSlipRateConstraintWt_normalized(): "
-                            + config.getSlipRateConstraintWt_normalized());
-            System.out.println(
-                    "config.getSlipRateConstraintWt_unnormalized(): "
-                            + config.getSlipRateConstraintWt_unnormalized());
-        }
-        System.out.println(
-                "config.getMinimizationConstraintWt(): " + config.getMinimizationConstraintWt());
-        System.out.println(
-                "config.getMagnitudeEqualityConstraintWt(): "
-                        + config.getMagnitudeEqualityConstraintWt());
-        System.out.println(
-                "config.getMagnitudeInequalityConstraintWt(): "
-                        + config.getMagnitudeInequalityConstraintWt());
-        System.out.println(
-                "config.getNucleationMFDConstraintWt():" + config.getNucleationMFDConstraintWt());
-
-        // builds constraint instances
-        List<InversionConstraint> constraints = new ArrayList<>();
-
-        if (config.getSlipRateWeightingType()
-                == AbstractInversionConfiguration.NZSlipRateConstraintWeightingType
-                        .NORMALIZED_BY_UNCERTAINTY) {
-            constraints.add(
-                    NZSHM22_SlipRateInversionConstraintBuilder.buildUncertaintyConstraint(
-                            config.getSlipRateUncertaintyConstraintWt(),
-                            rupSet,
-                            config.getSlipRateUncertaintyConstraintScalingFactor(),
-                            config.getUnmodifiedSlipRateStdvs()));
-        } else {
-            if (config.getSlipRateConstraintWt_normalized() > 0d
-                    && (config.getSlipRateWeightingType()
-                                    == AbstractInversionConfiguration
-                                            .NZSlipRateConstraintWeightingType.NORMALIZED
-                            || config.getSlipRateWeightingType()
-                                    == AbstractInversionConfiguration
-                                            .NZSlipRateConstraintWeightingType.BOTH)) {
-                constraints.add(
-                        new SlipRateInversionConstraint(
-                                config.getSlipRateConstraintWt_normalized(),
-                                ConstraintWeightingType.NORMALIZED,
-                                rupSet));
-            }
-
-            if (config.getSlipRateConstraintWt_unnormalized() > 0d
-                    && (config.getSlipRateWeightingType()
-                                    == AbstractInversionConfiguration
-                                            .NZSlipRateConstraintWeightingType.UNNORMALIZED
-                            || config.getSlipRateWeightingType()
-                                    == AbstractInversionConfiguration
-                                            .NZSlipRateConstraintWeightingType.BOTH)) {
-                constraints.add(
-                        new SlipRateInversionConstraint(
-                                config.getSlipRateConstraintWt_unnormalized(),
-                                ConstraintWeightingType.UNNORMALIZED,
-                                rupSet));
-            }
-        }
-
-        if (config.getPaleoRateConstraintWt() > 0) {
-            constraints.add(
-                    new PaleoRateInversionConstraint(
-                            rupSet,
-                            config.getPaleoRateConstraintWt(),
-                            paleoRateConstraints,
-                            paleoProbabilityModel));
-
-            if (config.getpaleoParentRateSmoothnessConstraintWeight() > 0) {
-                HashSet<Integer> paleoParentIDs = new HashSet();
-                for (UncertainDataConstraint.SectMappedUncertainDataConstraint constraint :
-                        paleoRateConstraints) {
-                    paleoParentIDs.add(
-                            rupSet.getFaultSectionDataList()
-                                    .get(constraint.sectionIndex)
-                                    .getParentSectionId());
-                }
-                constraints.add(
-                        new LaplacianSmoothingInversionConstraint(
-                                rupSet,
-                                config.getpaleoParentRateSmoothnessConstraintWeight(),
-                                paleoParentIDs));
-            }
-        }
-
-        //		if (config.getPaleoSlipConstraintWt() > 0d)
-        //			constraints.add(new PaleoSlipInversionConstraint(rupSet,
-        // config.getPaleoSlipConstraintWt(),
-        //					aveSlipConstraints, sectSlipRateReduced));
-        ////
-        //		if (config.getRupRateConstraintWt() > 0d) {
-        //			// This is the RupRateConstraintWt for ruptures not in UCERF2
-        //			double zeroRupRateConstraintWt = 0;
-        //			if (config.isAPrioriConstraintForZeroRates())
-        //				zeroRupRateConstraintWt =
-        // config.getRupRateConstraintWt()*config.getAPrioriConstraintForZeroRatesWtFactor();
-        //			constraints.add(new APrioriInversionConstraint(config.getRupRateConstraintWt(),
-        // zeroRupRateConstraintWt, config.getA_PrioriRupConstraint()));
-        //		}
-
-        //		// This constrains rates of ruptures that differ by only 1 subsection
-        //		if (config.getRupRateSmoothingConstraintWt() > 0)
-        //			constraints.add(new
-        // RupRateSmoothingInversionConstraint(config.getRupRateSmoothingConstraintWt(), rupSet));
-        //
-
-        // Rupture rate minimization constraint
-        // Minimize the rates of ruptures below SectMinMag (strongly so that they have
-        // zero rates)
-        if (config.getMinimizationConstraintWt() > 0.0) {
-            List<Integer> belowMinIndexes = new ArrayList<>();
-            for (int r = 0; r < rupSet.getNumRuptures(); r++)
-                if (rupSet.isRuptureBelowSectMinMag(r)) belowMinIndexes.add(r);
-            constraints.add(
-                    new RupRateMinimizationConstraint(
-                            config.getMinimizationConstraintWt(), belowMinIndexes));
-        }
-
-        // Constrain Solution MFD to equal the Target MFD
-        // This is for equality constraints only -- inequality constraints must be
-        // encoded into the A_ineq matrix instead since they are nonlinear
-        if (config.getMagnitudeEqualityConstraintWt() > 0.0) {
-            constraints.add(
-                    new MFDInversionConstraint(
-                            rupSet,
-                            config.getMagnitudeEqualityConstraintWt(),
-                            false,
-                            config.getMfdEqualityConstraints()));
-        }
-
-        // Prepare MFD Inequality Constraint (not added to A matrix directly since it's
-        // nonlinear)
-        if (config.getMagnitudeInequalityConstraintWt() > 0.0) {
-            constraints.add(
-                    new MFDInversionConstraint(
-                            rupSet,
-                            config.getMagnitudeInequalityConstraintWt(),
-                            true,
-                            config.getMfdInequalityConstraints()));
-        }
-
-        // Prepare MFD Uncertainty Weighted Constraint
-        if (config.getMagnitudeUncertaintyWeightedConstraintWt() > 0.0)
-            constraints.add(
-                    new MFDInversionConstraint(
-                            rupSet,
-                            config.getMagnitudeUncertaintyWeightedConstraintWt(),
-                            false,
-                            ConstraintWeightingType.NORMALIZED_BY_UNCERTAINTY,
-                            config.getMfdUncertaintyWeightedConstraints()));
-
-        //		// MFD Smoothness Constraint - Constrain participation MFD to be uniform for each fault
-        // subsection
-        //		if (config.getParticipationSmoothnessConstraintWt() > 0.0)
-        //			constraints.add(new MFDParticipationSmoothnessInversionConstraint(rupSet,
-        //					config.getParticipationSmoothnessConstraintWt(),
-        // config.getParticipationConstraintMagBinSize()));
-
-        // MFD Subsection nucleation MFD constraint
-        ArrayList<U3SectionMFD_constraint> MFDConstraints = null;
-        if (config.getNucleationMFDConstraintWt() > 0.0) {
-            MFDConstraints =
-                    NZSHM22_FaultSystemRupSetCalc.getCharInversionSectMFD_Constraints(rupSet);
-            constraints.add(
-                    new U3MFDSubSectNuclInversionConstraint(
-                            rupSet, config.getNucleationMFDConstraintWt(), MFDConstraints));
-        }
-
-        //		// MFD Smoothing constraint - MFDs spatially smooth along adjacent subsections on a
-        // parent section (Laplacian smoothing)
-        //		if (config.getMFDSmoothnessConstraintWt() > 0.0 ||
-        // config.getMFDSmoothnessConstraintWtForPaleoParents() > 0.0) {
-        //			if (MFDConstraints == null)
-        //				MFDConstraints = FaultSystemRupSetCalc.getCharInversionSectMFD_Constraints(rupSet);
-        //
-        //			HashSet<Integer> paleoParentIDs = new HashSet<>();
-        //			// Get list of parent IDs that have a paleo data point (paleo event rate or paleo mean
-        // slip)
-        //			if (config.getPaleoRateConstraintWt() > 0.0) {
-        //				for (int i=0; i<paleoRateConstraints.size(); i++) {
-        //					int paleoParentID =
-        // rupSet.getFaultSectionDataList().get(paleoRateConstraints.get(i).getSectionIndex()).getParentSectionId();
-        //					paleoParentIDs.add(paleoParentID);
-        //				}
-        //			}
-
-        //			if (config.getPaleoSlipConstraintWt() > 0.0) {
-        //				for (int i=0; i<aveSlipConstraints.size(); i++) {
-        //					int paleoParentID =
-        // rupSet.getFaultSectionDataList().get(aveSlipConstraints.get(i).getSubSectionIndex()).getParentSectionId();
-        //					paleoParentIDs.add(paleoParentID);
-        //				}
-        //			}
-        //
-        //			constraints.add(new MFDLaplacianSmoothingInversionConstraint(rupSet,
-        // config.getMFDSmoothnessConstraintWt(),
-        //					config.getMFDSmoothnessConstraintWtForPaleoParents(), paleoParentIDs,
-        // MFDConstraints));
-        //		}
-
-        //		// Constraint solution moment to equal deformation-model moment
-        //		if (config.getMomentConstraintWt() > 0.0)
-        //			constraints.add(new TotalMomentInversionConstraint(rupSet,
-        // config.getMomentConstraintWt(), rupSet.getTotalReducedMomentRate()));
-        //
-
-        //		// Constrain paleoseismically-visible event rates along parent sections to be smooth
-        //		if (config.getEventRateSmoothnessWt() > 0.0)
-        //			constraints.add(new PaleoVisibleEventRateSmoothnessInversionConstraint(rupSet,
-        // config.getEventRateSmoothnessWt(), paleoProbabilityModel));
-
-        return constraints;
-    }
-
-    private static double[] buildWaterLevel(
-            NZSHM22_CrustalInversionConfiguration config, FaultSystemRupSet rupSet) {
-        double minimumRuptureRateFraction = config.getMinimumRuptureRateFraction();
-        if (minimumRuptureRateFraction > 0) {
-            // set up minimum rupture rates (water level)
-            double[] minimumRuptureRateBasis = config.getMinimumRuptureRateBasis();
-            Preconditions.checkNotNull(
-                    minimumRuptureRateBasis,
-                    "minimum rate fraction specified but no minimum rate basis given!");
-
-            // first check to make sure that they're not all zeros
-            boolean allZeros = true;
-            int numRuptures = rupSet.getNumRuptures();
-            for (int i = 0; i < numRuptures; i++) {
-                if (minimumRuptureRateBasis[i] > 0) {
-                    allZeros = false;
-                    break;
-                }
-            }
-            Preconditions.checkState(
-                    !allZeros, "cannot set water level when water level rates are all zero!");
-
-            double[] minimumRuptureRates = new double[numRuptures];
-            for (int i = 0; i < numRuptures; i++)
-                minimumRuptureRates[i] = minimumRuptureRateBasis[i] * minimumRuptureRateFraction;
-            return minimumRuptureRates;
-        }
-        return null;
-    }
-
-    public void generateInputs() {
-        generateInputs(null, D);
-    }
-
-    /**
-     * This returns the normalized distance along a rupture that a paleoseismic trench is located
-     * (Glenn's x/L). It is between 0 and 0.5. This currently puts the trench in the middle of the
-     * subsection. We need this for the UCERF3 probability of detecting a rupture in a trench.
-     *
-     * @return
-     */
-    public static double getDistanceAlongRupture(
-            List<FaultSection> sectsInRup, int targetSectIndex) {
-        return getDistanceAlongRupture(sectsInRup, targetSectIndex, null);
-    }
-
-    public static double getDistanceAlongRupture(
-            List<FaultSection> sectsInRup,
-            int targetSectIndex,
-            Map<Integer, Double> traceLengthCache) {
-        double distanceAlongRup = 0;
-
-        double totalLength = 0;
-        double lengthToRup = 0;
-        boolean reachConstraintLoc = false;
-
-        // Find total length (km) of fault trace and length (km) from one end to the
-        // paleo trench location
-        for (int i = 0; i < sectsInRup.size(); i++) {
-            FaultSection sect = sectsInRup.get(i);
-            int sectIndex = sect.getSectionId();
-            Double sectLength = null;
-            if (traceLengthCache != null) {
-                sectLength = traceLengthCache.get(sectIndex);
-                if (sectLength == null) {
-                    sectLength = sect.getFaultTrace().getTraceLength();
-                    traceLengthCache.put(sectIndex, sectLength);
-                }
-            } else {
-                sectLength = sect.getFaultTrace().getTraceLength();
-            }
-            totalLength += sectLength;
-            if (sectIndex == targetSectIndex) {
-                reachConstraintLoc = true;
-                // We're putting the trench in the middle of the subsection for now
-                lengthToRup += sectLength / 2;
-            }
-            // We haven't yet gotten to the trench subsection so keep adding to lengthToRup
-            if (reachConstraintLoc == false) lengthToRup += sectLength;
-        }
-
-        if (!reachConstraintLoc) // check to make sure we came across the trench subsection in the
-            // rupture
-            throw new IllegalStateException(
-                    "Paleo site subsection was not included in rupture subsections");
-
-        // Normalized distance along the rainbow (Glenn's x/L) - between 0 and 1
-        distanceAlongRup = lengthToRup / totalLength;
-        // Adjust to be between 0 and 0.5 (since rainbow is symmetric about 0.5)
-        if (distanceAlongRup > 0.5) distanceAlongRup = 1 - distanceAlongRup;
-
-        return distanceAlongRup;
-    }
-
-    public AbstractInversionConfiguration getConfig() {
-        return config;
-    }
-
-    public List<UncertainDataConstraint.SectMappedUncertainDataConstraint>
-            getPaleoRateConstraints() {
-        return paleoRateConstraints;
-    }
-
-    public double[] getImprobabilityConstraint() {
-        return improbabilityConstraint;
-    }
-
-    public PaleoProbabilityModel getPaleoProbabilityModel() {
-        return paleoProbabilityModel;
-    }
-}
+package nz.cri.gns.NZSHM22.opensha.inversion;
+
+import com.google.common.base.Preconditions;
+import java.io.IOException;
+import java.util.*;
+import nz.cri.gns.NZSHM22.opensha.analysis.NZSHM22_FaultSystemRupSetCalc;
+import org.opensha.sha.earthquake.faultSysSolution.FaultSystemRupSet;
+import org.opensha.sha.earthquake.faultSysSolution.inversion.InversionInputGenerator;
+import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.ConstraintWeightingType;
+import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.InversionConstraint;
+import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.impl.*;
+import org.opensha.sha.faultSurface.FaultSection;
+import scratch.UCERF3.utils.U3SectionMFD_constraint;
+import scratch.UCERF3.utils.aveSlip.U3AveSlipConstraint;
+import scratch.UCERF3.utils.paleoRateConstraints.UCERF3_PaleoProbabilityModel;
+
+/**
+ * This class is used to generate inversion inputs (A/A_ineq matrices, d/d_ineq vectors) for a given
+ * rupture set, inversion configuration, paleo rate constraints, improbability constraint, and paleo
+ * probability model. It can also save these inputs to a zip file to be run on high performance
+ * computing.
+ */
+public class NZSHM22_CrustalInversionInputGenerator extends InversionInputGenerator {
+
+    private static final boolean D = false;
+    /**
+     * this enables use of the getQuick and setQuick methods on the sparse matrices. this comes with
+     * a performance boost, but disables range checks and is more prone to errors.
+     */
+    private static final boolean QUICK_GETS_SETS = true;
+
+    // inputs
+    private NZSHM22_InversionFaultSystemRuptSet rupSet;
+    private AbstractInversionConfiguration config;
+    private List<UncertainDataConstraint.SectMappedUncertainDataConstraint> paleoRateConstraints;
+    private List<U3AveSlipConstraint> aveSlipConstraints;
+    private double[] improbabilityConstraint;
+    private PaleoProbabilityModel paleoProbabilityModel;
+
+    public NZSHM22_CrustalInversionInputGenerator(
+            NZSHM22_InversionFaultSystemRuptSet rupSet,
+            NZSHM22_CrustalInversionConfiguration config,
+            List<UncertainDataConstraint.SectMappedUncertainDataConstraint> paleoRateConstraints,
+            List<U3AveSlipConstraint> aveSlipConstraints,
+            double[] improbabilityConstraint, // may become an object in the future
+            PaleoProbabilityModel paleoProbabilityModel) {
+        super(
+                rupSet,
+                buildConstraints(
+                        rupSet,
+                        config,
+                        paleoRateConstraints,
+                        aveSlipConstraints,
+                        paleoProbabilityModel),
+                config.getInitialRupModel(),
+                buildWaterLevel(config, rupSet));
+        this.rupSet = rupSet;
+        this.config = config;
+        this.paleoRateConstraints = paleoRateConstraints;
+        this.improbabilityConstraint = improbabilityConstraint;
+        this.aveSlipConstraints = aveSlipConstraints;
+        this.paleoProbabilityModel = paleoProbabilityModel;
+    }
+
+    private static PaleoProbabilityModel defaultProbModel = null;
+
+    /**
+     * Loads the default paleo probability model for UCERF3 (Glenn's file). Can be turned into an
+     * enum if we get alternatives
+     *
+     * @return
+     * @throws IOException
+     */
+    public static PaleoProbabilityModel loadDefaultPaleoProbabilityModel() throws IOException {
+        if (defaultProbModel == null) defaultProbModel = UCERF3_PaleoProbabilityModel.load();
+        return defaultProbModel;
+    }
+
+    private static List<InversionConstraint> buildConstraints(
+            NZSHM22_InversionFaultSystemRuptSet rupSet,
+            NZSHM22_CrustalInversionConfiguration config,
+            List<UncertainDataConstraint.SectMappedUncertainDataConstraint> paleoRateConstraints,
+            List<U3AveSlipConstraint> aveSlipConstraints,
+            PaleoProbabilityModel paleoProbabilityModel) {
+
+        System.out.println("buildConstraints");
+        System.out.println("================");
+
+        System.out.println(
+                "config.getSlipRateWeightingType(): " + config.getSlipRateWeightingType());
+        if (config.getSlipRateWeightingType()
+                == AbstractInversionConfiguration.NZSlipRateConstraintWeightingType
+                        .NORMALIZED_BY_UNCERTAINTY) {
+            System.out.println(
+                    "config.getSlipRateUncertaintyConstraintWt() :"
+                            + config.getSlipRateUncertaintyConstraintWt());
+            System.out.println(
+                    "config.getSlipRateUncertaintyConstraintScalingFactor() :"
+                            + config.getSlipRateUncertaintyConstraintScalingFactor());
+        } else {
+            System.out.println(
+                    "config.getSlipRateConstraintWt_normalized(): "
+                            + config.getSlipRateConstraintWt_normalized());
+            System.out.println(
+                    "config.getSlipRateConstraintWt_unnormalized(): "
+                            + config.getSlipRateConstraintWt_unnormalized());
+        }
+        System.out.println(
+                "config.getMinimizationConstraintWt(): " + config.getMinimizationConstraintWt());
+        System.out.println(
+                "config.getMagnitudeEqualityConstraintWt(): "
+                        + config.getMagnitudeEqualityConstraintWt());
+        System.out.println(
+                "config.getMagnitudeInequalityConstraintWt(): "
+                        + config.getMagnitudeInequalityConstraintWt());
+        System.out.println(
+                "config.getNucleationMFDConstraintWt():" + config.getNucleationMFDConstraintWt());
+
+        // builds constraint instances
+        List<InversionConstraint> constraints = new ArrayList<>();
+
+        if (config.getSlipRateWeightingType()
+                == AbstractInversionConfiguration.NZSlipRateConstraintWeightingType
+                        .NORMALIZED_BY_UNCERTAINTY) {
+            constraints.add(
+                    NZSHM22_SlipRateInversionConstraintBuilder.buildUncertaintyConstraint(
+                            config.getSlipRateUncertaintyConstraintWt(),
+                            rupSet,
+                            config.getSlipRateUncertaintyConstraintScalingFactor(),
+                            config.getUnmodifiedSlipRateStdvs()));
+        } else {
+            if (config.getSlipRateConstraintWt_normalized() > 0d
+                    && (config.getSlipRateWeightingType()
+                                    == AbstractInversionConfiguration
+                                            .NZSlipRateConstraintWeightingType.NORMALIZED
+                            || config.getSlipRateWeightingType()
+                                    == AbstractInversionConfiguration
+                                            .NZSlipRateConstraintWeightingType.BOTH)) {
+                constraints.add(
+                        new SlipRateInversionConstraint(
+                                config.getSlipRateConstraintWt_normalized(),
+                                ConstraintWeightingType.NORMALIZED,
+                                rupSet));
+            }
+
+            if (config.getSlipRateConstraintWt_unnormalized() > 0d
+                    && (config.getSlipRateWeightingType()
+                                    == AbstractInversionConfiguration
+                                            .NZSlipRateConstraintWeightingType.UNNORMALIZED
+                            || config.getSlipRateWeightingType()
+                                    == AbstractInversionConfiguration
+                                            .NZSlipRateConstraintWeightingType.BOTH)) {
+                constraints.add(
+                        new SlipRateInversionConstraint(
+                                config.getSlipRateConstraintWt_unnormalized(),
+                                ConstraintWeightingType.UNNORMALIZED,
+                                rupSet));
+            }
+        }
+
+        if (config.getPaleoRateConstraintWt() > 0) {
+            constraints.add(
+                    new PaleoRateInversionConstraint(
+                            rupSet,
+                            config.getPaleoRateConstraintWt(),
+                            paleoRateConstraints,
+                            paleoProbabilityModel));
+
+            if (config.getpaleoParentRateSmoothnessConstraintWeight() > 0) {
+                HashSet<Integer> paleoParentIDs = new HashSet();
+                for (UncertainDataConstraint.SectMappedUncertainDataConstraint constraint :
+                        paleoRateConstraints) {
+                    paleoParentIDs.add(
+                            rupSet.getFaultSectionDataList()
+                                    .get(constraint.sectionIndex)
+                                    .getParentSectionId());
+                }
+                constraints.add(
+                        new LaplacianSmoothingInversionConstraint(
+                                rupSet,
+                                config.getpaleoParentRateSmoothnessConstraintWeight(),
+                                paleoParentIDs));
+            }
+        }
+
+        //		if (config.getPaleoSlipConstraintWt() > 0d)
+        //			constraints.add(new PaleoSlipInversionConstraint(rupSet,
+        // config.getPaleoSlipConstraintWt(),
+        //					aveSlipConstraints, sectSlipRateReduced));
+        ////
+        //		if (config.getRupRateConstraintWt() > 0d) {
+        //			// This is the RupRateConstraintWt for ruptures not in UCERF2
+        //			double zeroRupRateConstraintWt = 0;
+        //			if (config.isAPrioriConstraintForZeroRates())
+        //				zeroRupRateConstraintWt =
+        // config.getRupRateConstraintWt()*config.getAPrioriConstraintForZeroRatesWtFactor();
+        //			constraints.add(new APrioriInversionConstraint(config.getRupRateConstraintWt(),
+        // zeroRupRateConstraintWt, config.getA_PrioriRupConstraint()));
+        //		}
+
+        //		// This constrains rates of ruptures that differ by only 1 subsection
+        //		if (config.getRupRateSmoothingConstraintWt() > 0)
+        //			constraints.add(new
+        // RupRateSmoothingInversionConstraint(config.getRupRateSmoothingConstraintWt(), rupSet));
+        //
+
+        // Rupture rate minimization constraint
+        // Minimize the rates of ruptures below SectMinMag (strongly so that they have
+        // zero rates)
+        if (config.getMinimizationConstraintWt() > 0.0) {
+            List<Integer> belowMinIndexes = new ArrayList<>();
+            for (int r = 0; r < rupSet.getNumRuptures(); r++)
+                if (rupSet.isRuptureBelowSectMinMag(r)) belowMinIndexes.add(r);
+            constraints.add(
+                    new RupRateMinimizationConstraint(
+                            config.getMinimizationConstraintWt(), belowMinIndexes));
+        }
+
+        // Constrain Solution MFD to equal the Target MFD
+        // This is for equality constraints only -- inequality constraints must be
+        // encoded into the A_ineq matrix instead since they are nonlinear
+        if (config.getMagnitudeEqualityConstraintWt() > 0.0) {
+            constraints.add(
+                    new MFDInversionConstraint(
+                            rupSet,
+                            config.getMagnitudeEqualityConstraintWt(),
+                            false,
+                            config.getMfdEqualityConstraints()));
+        }
+
+        // Prepare MFD Inequality Constraint (not added to A matrix directly since it's
+        // nonlinear)
+        if (config.getMagnitudeInequalityConstraintWt() > 0.0) {
+            constraints.add(
+                    new MFDInversionConstraint(
+                            rupSet,
+                            config.getMagnitudeInequalityConstraintWt(),
+                            true,
+                            config.getMfdInequalityConstraints()));
+        }
+
+        // Prepare MFD Uncertainty Weighted Constraint
+        if (config.getMagnitudeUncertaintyWeightedConstraintWt() > 0.0)
+            constraints.add(
+                    new MFDInversionConstraint(
+                            rupSet,
+                            config.getMagnitudeUncertaintyWeightedConstraintWt(),
+                            false,
+                            ConstraintWeightingType.NORMALIZED_BY_UNCERTAINTY,
+                            config.getMfdUncertaintyWeightedConstraints()));
+
+        //		// MFD Smoothness Constraint - Constrain participation MFD to be uniform for each fault
+        // subsection
+        //		if (config.getParticipationSmoothnessConstraintWt() > 0.0)
+        //			constraints.add(new MFDParticipationSmoothnessInversionConstraint(rupSet,
+        //					config.getParticipationSmoothnessConstraintWt(),
+        // config.getParticipationConstraintMagBinSize()));
+
+        // MFD Subsection nucleation MFD constraint
+        ArrayList<U3SectionMFD_constraint> MFDConstraints = null;
+        if (config.getNucleationMFDConstraintWt() > 0.0) {
+            MFDConstraints =
+                    NZSHM22_FaultSystemRupSetCalc.getCharInversionSectMFD_Constraints(rupSet);
+            constraints.add(
+                    new U3MFDSubSectNuclInversionConstraint(
+                            rupSet, config.getNucleationMFDConstraintWt(), MFDConstraints));
+        }
+
+        //		// MFD Smoothing constraint - MFDs spatially smooth along adjacent subsections on a
+        // parent section (Laplacian smoothing)
+        //		if (config.getMFDSmoothnessConstraintWt() > 0.0 ||
+        // config.getMFDSmoothnessConstraintWtForPaleoParents() > 0.0) {
+        //			if (MFDConstraints == null)
+        //				MFDConstraints = FaultSystemRupSetCalc.getCharInversionSectMFD_Constraints(rupSet);
+        //
+        //			HashSet<Integer> paleoParentIDs = new HashSet<>();
+        //			// Get list of parent IDs that have a paleo data point (paleo event rate or paleo mean
+        // slip)
+        //			if (config.getPaleoRateConstraintWt() > 0.0) {
+        //				for (int i=0; i<paleoRateConstraints.size(); i++) {
+        //					int paleoParentID =
+        // rupSet.getFaultSectionDataList().get(paleoRateConstraints.get(i).getSectionIndex()).getParentSectionId();
+        //					paleoParentIDs.add(paleoParentID);
+        //				}
+        //			}
+
+        //			if (config.getPaleoSlipConstraintWt() > 0.0) {
+        //				for (int i=0; i<aveSlipConstraints.size(); i++) {
+        //					int paleoParentID =
+        // rupSet.getFaultSectionDataList().get(aveSlipConstraints.get(i).getSubSectionIndex()).getParentSectionId();
+        //					paleoParentIDs.add(paleoParentID);
+        //				}
+        //			}
+        //
+        //			constraints.add(new MFDLaplacianSmoothingInversionConstraint(rupSet,
+        // config.getMFDSmoothnessConstraintWt(),
+        //					config.getMFDSmoothnessConstraintWtForPaleoParents(), paleoParentIDs,
+        // MFDConstraints));
+        //		}
+
+        //		// Constraint solution moment to equal deformation-model moment
+        //		if (config.getMomentConstraintWt() > 0.0)
+        //			constraints.add(new TotalMomentInversionConstraint(rupSet,
+        // config.getMomentConstraintWt(), rupSet.getTotalReducedMomentRate()));
+        //
+
+        //		// Constrain paleoseismically-visible event rates along parent sections to be smooth
+        //		if (config.getEventRateSmoothnessWt() > 0.0)
+        //			constraints.add(new PaleoVisibleEventRateSmoothnessInversionConstraint(rupSet,
+        // config.getEventRateSmoothnessWt(), paleoProbabilityModel));
+
+        return constraints;
+    }
+
+    private static double[] buildWaterLevel(
+            NZSHM22_CrustalInversionConfiguration config, FaultSystemRupSet rupSet) {
+        double minimumRuptureRateFraction = config.getMinimumRuptureRateFraction();
+        if (minimumRuptureRateFraction > 0) {
+            // set up minimum rupture rates (water level)
+            double[] minimumRuptureRateBasis = config.getMinimumRuptureRateBasis();
+            Preconditions.checkNotNull(
+                    minimumRuptureRateBasis,
+                    "minimum rate fraction specified but no minimum rate basis given!");
+
+            // first check to make sure that they're not all zeros
+            boolean allZeros = true;
+            int numRuptures = rupSet.getNumRuptures();
+            for (int i = 0; i < numRuptures; i++) {
+                if (minimumRuptureRateBasis[i] > 0) {
+                    allZeros = false;
+                    break;
+                }
+            }
+            Preconditions.checkState(
+                    !allZeros, "cannot set water level when water level rates are all zero!");
+
+            double[] minimumRuptureRates = new double[numRuptures];
+            for (int i = 0; i < numRuptures; i++)
+                minimumRuptureRates[i] = minimumRuptureRateBasis[i] * minimumRuptureRateFraction;
+            return minimumRuptureRates;
+        }
+        return null;
+    }
+
+    public void generateInputs() {
+        generateInputs(null, D);
+    }
+
+    /**
+     * This returns the normalized distance along a rupture that a paleoseismic trench is located
+     * (Glenn's x/L). It is between 0 and 0.5. This currently puts the trench in the middle of the
+     * subsection. We need this for the UCERF3 probability of detecting a rupture in a trench.
+     *
+     * @return
+     */
+    public static double getDistanceAlongRupture(
+            List<FaultSection> sectsInRup, int targetSectIndex) {
+        return getDistanceAlongRupture(sectsInRup, targetSectIndex, null);
+    }
+
+    public static double getDistanceAlongRupture(
+            List<FaultSection> sectsInRup,
+            int targetSectIndex,
+            Map<Integer, Double> traceLengthCache) {
+        double distanceAlongRup = 0;
+
+        double totalLength = 0;
+        double lengthToRup = 0;
+        boolean reachConstraintLoc = false;
+
+        // Find total length (km) of fault trace and length (km) from one end to the
+        // paleo trench location
+        for (int i = 0; i < sectsInRup.size(); i++) {
+            FaultSection sect = sectsInRup.get(i);
+            int sectIndex = sect.getSectionId();
+            Double sectLength = null;
+            if (traceLengthCache != null) {
+                sectLength = traceLengthCache.get(sectIndex);
+                if (sectLength == null) {
+                    sectLength = sect.getFaultTrace().getTraceLength();
+                    traceLengthCache.put(sectIndex, sectLength);
+                }
+            } else {
+                sectLength = sect.getFaultTrace().getTraceLength();
+            }
+            totalLength += sectLength;
+            if (sectIndex == targetSectIndex) {
+                reachConstraintLoc = true;
+                // We're putting the trench in the middle of the subsection for now
+                lengthToRup += sectLength / 2;
+            }
+            // We haven't yet gotten to the trench subsection so keep adding to lengthToRup
+            if (reachConstraintLoc == false) lengthToRup += sectLength;
+        }
+
+        if (!reachConstraintLoc) // check to make sure we came across the trench subsection in the
+            // rupture
+            throw new IllegalStateException(
+                    "Paleo site subsection was not included in rupture subsections");
+
+        // Normalized distance along the rainbow (Glenn's x/L) - between 0 and 1
+        distanceAlongRup = lengthToRup / totalLength;
+        // Adjust to be between 0 and 0.5 (since rainbow is symmetric about 0.5)
+        if (distanceAlongRup > 0.5) distanceAlongRup = 1 - distanceAlongRup;
+
+        return distanceAlongRup;
+    }
+
+    public AbstractInversionConfiguration getConfig() {
+        return config;
+    }
+
+    public List<UncertainDataConstraint.SectMappedUncertainDataConstraint>
+            getPaleoRateConstraints() {
+        return paleoRateConstraints;
+    }
+
+    public double[] getImprobabilityConstraint() {
+        return improbabilityConstraint;
+    }
+
+    public PaleoProbabilityModel getPaleoProbabilityModel() {
+        return paleoProbabilityModel;
+    }
+}
diff --git a/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/NZSHM22_SubductionInversionConfiguration.java b/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/NZSHM22_SubductionInversionConfiguration.java
index b46184f..1833df4 100644
--- a/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/NZSHM22_SubductionInversionConfiguration.java
+++ b/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/NZSHM22_SubductionInversionConfiguration.java
@@ -1,382 +1,382 @@
-package nz.cri.gns.NZSHM22.opensha.inversion;
-
-import com.google.common.base.Preconditions;
-import java.util.ArrayList;
-import java.util.List;
-import org.opensha.commons.data.uncertainty.UncertainIncrMagFreqDist;
-import org.opensha.sha.earthquake.faultSysSolution.FaultSystemRupSet;
-import org.opensha.sha.magdist.IncrementalMagFreqDist;
-import scratch.UCERF3.enumTreeBranches.InversionModels;
-import scratch.UCERF3.inversion.UCERF3InversionConfiguration;
-
-/**
- * This represents all of the inversion configuration parameters specific to an individual model on
- * the NZSHM22 logic tree. Parameters can be fetched for a given logic tree branch with the <code>
- * forModel(...)</code> method.
- *
- * <p>based on scratch.UCERF3.inversion.UCERF3InversionConfiguration
- *
- * @author chrisbc
- */
-public class NZSHM22_SubductionInversionConfiguration extends AbstractInversionConfiguration {
-
-    protected static final boolean D = true; // for debugging
-
-    /** */
-    public NZSHM22_SubductionInversionConfiguration() {}
-
-    public static final double DEFAULT_MFD_EQUALITY_WT = 10;
-    public static final double DEFAULT_MFD_INEQUALITY_WT = 1000;
-
-    /**
-     * This generates an inversion configuration for the given inversion model and rupture set
-     *
-     * @param model
-     * @param rupSet
-     * @return
-     */
-    public static NZSHM22_SubductionInversionConfiguration forModel(
-            InversionModels model, NZSHM22_InversionFaultSystemRuptSet rupSet) {
-        double mfdEqualityConstraintWt = DEFAULT_MFD_EQUALITY_WT;
-        double mfdInequalityConstraintWt = DEFAULT_MFD_INEQUALITY_WT;
-        return forModel(model, rupSet, mfdEqualityConstraintWt, mfdInequalityConstraintWt);
-    }
-
-    /**
-     * This generates an inversion configuration for the given inversion model and rupture set
-     *
-     * @param model
-     * @param rupSet
-     * @param mfdEqualityConstraintWt weight of magnitude-distribution EQUALITY constraint relative
-     *     to slip-rate constraint (recommended: 10)
-     * @param mfdInequalityConstraintWt weight of magnitude-distribution INEQUALITY constraint
-     *     relative to slip-rate constraint (recommended: 1000)
-     * @return
-     */
-    public static NZSHM22_SubductionInversionConfiguration forModel(
-            InversionModels model,
-            NZSHM22_InversionFaultSystemRuptSet rupSet,
-            double mfdEqualityConstraintWt,
-            double mfdInequalityConstraintWt) {
-        double totalRateM5 = 5;
-        double bValue = 1;
-        double mfdTransitionMag = 7.75;
-        double mfdMinMag = 7.05;
-        return forModel(
-                model,
-                rupSet,
-                null,
-                mfdEqualityConstraintWt,
-                mfdInequalityConstraintWt,
-                0,
-                0,
-                0.4,
-                totalRateM5,
-                bValue,
-                mfdTransitionMag,
-                mfdMinMag);
-    }
-
-    /**
-     * This generates an inversion configuration for the given inversion model and rupture set
-     *
-     * @param model
-     * @param rupSet
-     * @param mfdEqualityConstraintWt weight of magnitude-distribution EQUALITY constraint relative
-     *     to slip-rate constraint (recommended: 10)
-     * @param mfdInequalityConstraintWt weight of magnitude-distribution INEQUALITY constraint
-     *     relative to slip-rate constraint (recommended: 1000)
-     * @param mfdUncertaintyWeightedConstraintScalar TODO
-     * @param totalRateM5
-     * @param bValue
-     * @param mfdTransitionMag
-     * @return
-     */
-    public static NZSHM22_SubductionInversionConfiguration forModel(
-            InversionModels model,
-            NZSHM22_InversionFaultSystemRuptSet rupSet,
-            double[] initialSolution,
-            double mfdEqualityConstraintWt,
-            double mfdInequalityConstraintWt,
-            double mfdUncertaintyWeightedConstraintWt,
-            double mfdUncertaintyWeightedConstraintPower,
-            double mfdUncertaintyWeightedConstraintScalar,
-            double totalRateM5,
-            double bValue,
-            double mfdTransitionMag,
-            double mfdMinMag) {
-
-        double MFDTransitionMag =
-                mfdTransitionMag; // magnitude to switch from MFD equality to MFD inequality
-
-        /*
-         * ******************************************* COMMON TO ALL MODELS
-         * *******************************************
-         */
-        // Setting slip-rate constraint weights to 0 does not disable them! To disable
-        // one or the other (both cannot be), use slipConstraintRateWeightingType Below
-        double slipRateConstraintWt_normalized =
-                1; // For SlipRateConstraintWeightingType.NORMALIZED (also used for
-        // SlipRateConstraintWeightingType.BOTH) -- NOT USED if
-        // UNNORMALIZED!
-        double slipRateConstraintWt_unnormalized =
-                100; // For SlipRateConstraintWeightingType.UNNORMALIZED (also used
-        // for SlipRateConstraintWeightingType.BOTH) -- NOT USED if
-        // NORMALIZED!
-        // If normalized, slip rate misfit is % difference for each section (recommended
-        // since it helps fit slow-moving faults). If unnormalized, misfit is absolute
-        // difference.
-        // BOTH includes both normalized and unnormalized constraints.
-        NZSlipRateConstraintWeightingType slipRateWeighting =
-                NZSlipRateConstraintWeightingType.BOTH; // (recommended: BOTH)
-
-        // weight of magnitude-distribution EQUALITY constraint relative to slip-rate
-        // constraint (recommended: 10)
-        // mfdEqualityConstraintWt = 10;
-
-        // weight of magnitude-distribution INEQUALITY constraint relative to slip-rate
-        // constraint (recommended: 1000)
-        // double mfdInequalityConstraintWt = 1000;
-
-        // magnitude-bin size for MFD participation smoothness constraint
-        //		double participationConstraintMagBinSize = 0.1;
-
-        // weight of rupture-rate smoothing constraint
-        //		double rupRateSmoothingConstraintWt = 0;
-
-        // weight of rupture-rate minimization constraint weights relative to slip-rate
-        // constraint (recommended: 10,000)
-        // (currently used to minimization rates of rups below sectMinMag)
-        double minimizationConstraintWt = 10000;
-
-        // weight of entropy-maximization constraint (should smooth rupture rates)
-        // (recommended: 10000)
-        //		double smoothnessWt = 0;
-
-        // weight of Moment Constraint (set solution moment to equal deformation model
-        // moment) (recommended: 1e-17)
-        //		double momentConstraintWt = 0;
-
-        // setup MFD constraints
-        NZSHM22_SubductionInversionTargetMFDs inversionMFDs =
-                new NZSHM22_SubductionInversionTargetMFDs(
-                        rupSet,
-                        totalRateM5,
-                        bValue,
-                        mfdTransitionMag,
-                        mfdMinMag,
-                        mfdUncertaintyWeightedConstraintWt,
-                        mfdUncertaintyWeightedConstraintPower,
-                        mfdUncertaintyWeightedConstraintScalar);
-        rupSet.setInversionTargetMFDs(inversionMFDs);
-
-        //		NZSHM22_SubductionInversionTargetMFDs inversionTargetMfds =
-        // (NZSHM22_SubductionInversionTargetMFDs) rupSet.getInversionTargetMFDs();
-
-        String metadata = "";
-
-        //		/* *******************************************
-        //		 * MODEL SPECIFIC
-        //		 * ******************************************* */
-        //		// define model specific value here (leave them as null or unassigned, then set values
-        //		// in the below switch statement
-        //
-        //		// weight of nucleation MFD constraint - applied on subsection basis
-        double nucleationMFDConstraintWt;
-        // fraction of the minimum rupture rate basis to be used as initial rates
-        double minimumRuptureRateFraction = 0;
-        double[] initialRupModel = null;
-        double[] minimumRuptureRateBasis = null;
-
-        @SuppressWarnings("unchecked")
-        List<IncrementalMagFreqDist> mfdConstraints = new ArrayList<>();
-        mfdConstraints.addAll(inversionMFDs.getMfdEqIneqConstraints());
-        mfdConstraints.addAll(inversionMFDs.getMfdUncertaintyConstraints());
-
-        //		SummedMagFreqDist targetOnFaultMFD =
-        // rupSet.getInversionTargetMFDs().getOnFaultSupraSeisMFD();
-        IncrementalMagFreqDist targetOnFaultMFD = inversionMFDs.getTotalOnFaultSupraSeisMFD();
-
-        if (model == InversionModels.CHAR_CONSTRAINED) {
-            nucleationMFDConstraintWt = 0.01;
-            // For water level
-            minimumRuptureRateFraction = 0.0;
-
-            // Made local copy of adjustStartingModel as it's private in
-            // UCERF3InversionConfiguration
-            minimumRuptureRateBasis =
-                    adjustStartingModel(
-                            UCERF3InversionConfiguration.getSmoothStartingSolution(
-                                    rupSet, targetOnFaultMFD),
-                            mfdConstraints,
-                            rupSet,
-                            true);
-
-            if (initialSolution != null) {
-                Preconditions.checkArgument(
-                        rupSet.getNumRuptures() == initialSolution.length,
-                        "Initial solution is for the wrong number of ruptures.");
-                initialRupModel = initialSolution;
-            } else {
-                initialRupModel = new double[rupSet.getNumRuptures()];
-            }
-        }
-
-        /* end MODIFIERS */
-
-        // NSHM-style config using setter methods...
-        NZSHM22_SubductionInversionConfiguration newConfig =
-                (NZSHM22_SubductionInversionConfiguration)
-                        new NZSHM22_SubductionInversionConfiguration()
-                                .setInversionTargetMfds(inversionMFDs)
-                                // MFD config is now below
-                                // Slip Rate config
-                                .setSlipRateConstraintWt_normalized(slipRateConstraintWt_normalized)
-                                .setSlipRateConstraintWt_unnormalized(
-                                        slipRateConstraintWt_unnormalized)
-                                .setSlipRateWeightingType(slipRateWeighting)
-                                // Rate Minimization config
-                                .setMinimizationConstraintWt(minimizationConstraintWt)
-                                .setMinimumRuptureRateFraction(minimumRuptureRateFraction)
-                                .setMinimumRuptureRateBasis(minimumRuptureRateBasis)
-                                .setInitialRupModel(initialRupModel);
-
-        // MFD constraint configuration
-        List<IncrementalMagFreqDist> mfdInequalityConstraints = new ArrayList<>();
-        List<IncrementalMagFreqDist> mfdEqualityConstraints = new ArrayList<>();
-        List<UncertainIncrMagFreqDist> mfdUncertaintyWeightedConstraints = new ArrayList<>();
-
-        mfdConstraints = inversionMFDs.getMfdEqIneqConstraints();
-        if (mfdEqualityConstraintWt > 0.0 && mfdInequalityConstraintWt > 0.0) {
-            // we have both MFD constraints, apply a transition mag from equality to
-            // inequality
-            mfdEqualityConstraints =
-                    MFDManipulation.restrictMFDConstraintMagRange(
-                            mfdConstraints, mfdConstraints.get(0).getMinX(), MFDTransitionMag);
-            mfdInequalityConstraints =
-                    MFDManipulation.restrictMFDConstraintMagRange(
-                            mfdConstraints, MFDTransitionMag, mfdConstraints.get(0).getMaxX());
-            newConfig
-                    .setMagnitudeEqualityConstraintWt(mfdEqualityConstraintWt)
-                    .setMagnitudeInequalityConstraintWt(mfdInequalityConstraintWt)
-                    .setMfdEqualityConstraints(mfdEqualityConstraints)
-                    .setMfdInequalityConstraints(mfdInequalityConstraints);
-        } else if (mfdEqualityConstraintWt > 0.0) { // no ineq wt
-            mfdEqualityConstraints = mfdConstraints;
-            newConfig
-                    .setMagnitudeEqualityConstraintWt(mfdEqualityConstraintWt)
-                    .setMfdEqualityConstraints(mfdEqualityConstraints);
-        } else if (mfdInequalityConstraintWt > 0.0) { // no eq wt
-            mfdInequalityConstraints = mfdConstraints;
-            newConfig
-                    .setMagnitudeInequalityConstraintWt(mfdInequalityConstraintWt)
-                    .setMfdInequalityConstraints(mfdInequalityConstraints);
-        }
-
-        if (mfdUncertaintyWeightedConstraintWt > 0.0) {
-            mfdUncertaintyWeightedConstraints = inversionMFDs.getMfdUncertaintyConstraints();
-            newConfig
-                    .setMagnitudeUncertaintyWeightedConstraintWt(
-                            mfdUncertaintyWeightedConstraintWt) // NEW constraint
-                    .setMfdUncertaintyWeightedConstraints(mfdUncertaintyWeightedConstraints);
-        }
-
-        return newConfig;
-    }
-
-    /**
-     * CBC: cloned this from UCERF3InversionConfiguration just for testing with some water levels.
-     * It needs work to decided a) if its wanted and b) how it should work!! @MCG
-     *
-     * <p>This method adjusts the starting model to ensure that for each MFD inequality constraint
-     * magnitude-bin, the starting model is below the MFD. If adjustOnlyIfOverMFD = false, it will
-     * adjust the starting model so that it's MFD equals the MFD constraint. It will uniformly
-     * reduce the rates of ruptures in any magnitude bins that need adjusting.
-     */
-    private static double[] adjustStartingModel(
-            double[] initialRupModel,
-            List<IncrementalMagFreqDist> mfdInequalityConstraints,
-            FaultSystemRupSet rupSet,
-            boolean adjustOnlyIfOverMFD) {
-
-        double[] rupMeanMag = rupSet.getMagForAllRups();
-
-        for (int i = 0; i < mfdInequalityConstraints.size(); i++) {
-            double[] fractRupsInside =
-                    rupSet.getFractRupsInsideRegion(
-                            mfdInequalityConstraints.get(i).getRegion(), false);
-            IncrementalMagFreqDist targetMagFreqDist = mfdInequalityConstraints.get(i);
-            IncrementalMagFreqDist startingModelMagFreqDist =
-                    new IncrementalMagFreqDist(
-                            targetMagFreqDist.getMinX(),
-                            targetMagFreqDist.size(),
-                            targetMagFreqDist.getDelta());
-            startingModelMagFreqDist.setTolerance(0.1);
-
-            // Find the starting model MFD
-            for (int rup = 0; rup < rupSet.getNumRuptures(); rup++) {
-                double mag = rupMeanMag[rup];
-                double fractRupInside = fractRupsInside[rup];
-                if (fractRupInside > 0)
-                    if (mag < 8.5) // b/c the mfdInequalityConstraints only go to M8.5!
-                    startingModelMagFreqDist.add(mag, fractRupInside * initialRupModel[rup]);
-            }
-
-            // Find the amount to adjust starting model MFD to be below or equal to Target MFD
-            IncrementalMagFreqDist adjustmentRatio =
-                    new IncrementalMagFreqDist(
-                            targetMagFreqDist.getMinX(),
-                            targetMagFreqDist.size(),
-                            targetMagFreqDist.getDelta());
-            for (double m = targetMagFreqDist.getMinX();
-                    m <= targetMagFreqDist.getMaxX();
-                    m += targetMagFreqDist.getDelta()) {
-                if (adjustOnlyIfOverMFD == false)
-                    adjustmentRatio.set(
-                            m,
-                            targetMagFreqDist.getClosestYtoX(m)
-                                    / startingModelMagFreqDist.getClosestYtoX(m));
-                else {
-                    if (startingModelMagFreqDist.getClosestYtoX(m)
-                            > targetMagFreqDist.getClosestYtoX(m))
-                        adjustmentRatio.set(
-                                m,
-                                targetMagFreqDist.getClosestYtoX(m)
-                                        / startingModelMagFreqDist.getClosestYtoX(m));
-                    else adjustmentRatio.set(m, 1.0);
-                }
-            }
-
-            // Adjust initial model rates
-            for (int rup = 0; rup < rupSet.getNumRuptures(); rup++) {
-                double mag = rupMeanMag[rup];
-                if (!Double.isNaN(adjustmentRatio.getClosestYtoX(mag))
-                        && !Double.isInfinite(adjustmentRatio.getClosestYtoX(mag)))
-                    initialRupModel[rup] =
-                            initialRupModel[rup] * adjustmentRatio.getClosestYtoX(mag);
-            }
-        }
-
-        /*		// OPTIONAL: Adjust rates of largest rups to equal global target MFD
-        IncrementalMagFreqDist targetMagFreqDist = UCERF3_MFD_ConstraintFetcher.getTargetMFDConstraint(TimeAndRegion.ALL_CA_1850).getMagFreqDist();
-        IncrementalMagFreqDist startingModelMagFreqDist = new IncrementalMagFreqDist(targetMagFreqDist.getMinX(), targetMagFreqDist.getNum(), targetMagFreqDist.getDelta());
-        startingModelMagFreqDist.setTolerance(0.1);
-        for(int rup=0; rup<rupSet.getNumRuptures(); rup++) {
-        	double mag = rupMeanMag[rup];
-        	if (mag<8.5)
-        		startingModelMagFreqDist.add(mag, initialRupModel[rup]);
-        }
-        IncrementalMagFreqDist adjustmentRatio = new IncrementalMagFreqDist(targetMagFreqDist.getMinX(), targetMagFreqDist.getNum(), targetMagFreqDist.getDelta());
-        for (double m=targetMagFreqDist.getMinX(); m<=targetMagFreqDist.getMaxX(); m+= targetMagFreqDist.getDelta()) {
-        	if (m>8.0)	adjustmentRatio.set(m, targetMagFreqDist.getClosestY(m) / startingModelMagFreqDist.getClosestY(m));
-        	else adjustmentRatio.set(m, 1.0);
-        }
-        for(int rup=0; rup<rupSet.getNumRuptures(); rup++) {
-        	double mag = rupMeanMag[rup];
-        	if (!Double.isNaN(adjustmentRatio.getClosestY(mag)) && !Double.isInfinite(adjustmentRatio.getClosestY(mag)))
-        		initialRupModel[rup] = initialRupModel[rup] * adjustmentRatio.getClosestY(mag);
-        }	*/
-
-        return initialRupModel;
-    }
-}
+package nz.cri.gns.NZSHM22.opensha.inversion;
+
+import com.google.common.base.Preconditions;
+import java.util.ArrayList;
+import java.util.List;
+import org.opensha.commons.data.uncertainty.UncertainIncrMagFreqDist;
+import org.opensha.sha.earthquake.faultSysSolution.FaultSystemRupSet;
+import org.opensha.sha.magdist.IncrementalMagFreqDist;
+import scratch.UCERF3.enumTreeBranches.InversionModels;
+import scratch.UCERF3.inversion.UCERF3InversionConfiguration;
+
+/**
+ * This represents all of the inversion configuration parameters specific to an individual model on
+ * the NZSHM22 logic tree. Parameters can be fetched for a given logic tree branch with the <code>
+ * forModel(...)</code> method.
+ *
+ * <p>based on scratch.UCERF3.inversion.UCERF3InversionConfiguration
+ *
+ * @author chrisbc
+ */
+public class NZSHM22_SubductionInversionConfiguration extends AbstractInversionConfiguration {
+
+    protected static final boolean D = true; // for debugging
+
+    /** */
+    public NZSHM22_SubductionInversionConfiguration() {}
+
+    public static final double DEFAULT_MFD_EQUALITY_WT = 10;
+    public static final double DEFAULT_MFD_INEQUALITY_WT = 1000;
+
+    /**
+     * This generates an inversion configuration for the given inversion model and rupture set
+     *
+     * @param model
+     * @param rupSet
+     * @return
+     */
+    public static NZSHM22_SubductionInversionConfiguration forModel(
+            InversionModels model, NZSHM22_InversionFaultSystemRuptSet rupSet) {
+        double mfdEqualityConstraintWt = DEFAULT_MFD_EQUALITY_WT;
+        double mfdInequalityConstraintWt = DEFAULT_MFD_INEQUALITY_WT;
+        return forModel(model, rupSet, mfdEqualityConstraintWt, mfdInequalityConstraintWt);
+    }
+
+    /**
+     * This generates an inversion configuration for the given inversion model and rupture set
+     *
+     * @param model
+     * @param rupSet
+     * @param mfdEqualityConstraintWt weight of magnitude-distribution EQUALITY constraint relative
+     *     to slip-rate constraint (recommended: 10)
+     * @param mfdInequalityConstraintWt weight of magnitude-distribution INEQUALITY constraint
+     *     relative to slip-rate constraint (recommended: 1000)
+     * @return
+     */
+    public static NZSHM22_SubductionInversionConfiguration forModel(
+            InversionModels model,
+            NZSHM22_InversionFaultSystemRuptSet rupSet,
+            double mfdEqualityConstraintWt,
+            double mfdInequalityConstraintWt) {
+        double totalRateM5 = 5;
+        double bValue = 1;
+        double mfdTransitionMag = 7.75;
+        double mfdMinMag = 7.05;
+        return forModel(
+                model,
+                rupSet,
+                null,
+                mfdEqualityConstraintWt,
+                mfdInequalityConstraintWt,
+                0,
+                0,
+                0.4,
+                totalRateM5,
+                bValue,
+                mfdTransitionMag,
+                mfdMinMag);
+    }
+
+    /**
+     * This generates an inversion configuration for the given inversion model and rupture set
+     *
+     * @param model
+     * @param rupSet
+     * @param mfdEqualityConstraintWt weight of magnitude-distribution EQUALITY constraint relative
+     *     to slip-rate constraint (recommended: 10)
+     * @param mfdInequalityConstraintWt weight of magnitude-distribution INEQUALITY constraint
+     *     relative to slip-rate constraint (recommended: 1000)
+     * @param mfdUncertaintyWeightedConstraintScalar TODO
+     * @param totalRateM5
+     * @param bValue
+     * @param mfdTransitionMag
+     * @return
+     */
+    public static NZSHM22_SubductionInversionConfiguration forModel(
+            InversionModels model,
+            NZSHM22_InversionFaultSystemRuptSet rupSet,
+            double[] initialSolution,
+            double mfdEqualityConstraintWt,
+            double mfdInequalityConstraintWt,
+            double mfdUncertaintyWeightedConstraintWt,
+            double mfdUncertaintyWeightedConstraintPower,
+            double mfdUncertaintyWeightedConstraintScalar,
+            double totalRateM5,
+            double bValue,
+            double mfdTransitionMag,
+            double mfdMinMag) {
+
+        double MFDTransitionMag =
+                mfdTransitionMag; // magnitude to switch from MFD equality to MFD inequality
+
+        /*
+         * ******************************************* COMMON TO ALL MODELS
+         * *******************************************
+         */
+        // Setting slip-rate constraint weights to 0 does not disable them! To disable
+        // one or the other (both cannot be), use slipConstraintRateWeightingType Below
+        double slipRateConstraintWt_normalized =
+                1; // For SlipRateConstraintWeightingType.NORMALIZED (also used for
+        // SlipRateConstraintWeightingType.BOTH) -- NOT USED if
+        // UNNORMALIZED!
+        double slipRateConstraintWt_unnormalized =
+                100; // For SlipRateConstraintWeightingType.UNNORMALIZED (also used
+        // for SlipRateConstraintWeightingType.BOTH) -- NOT USED if
+        // NORMALIZED!
+        // If normalized, slip rate misfit is % difference for each section (recommended
+        // since it helps fit slow-moving faults). If unnormalized, misfit is absolute
+        // difference.
+        // BOTH includes both normalized and unnormalized constraints.
+        NZSlipRateConstraintWeightingType slipRateWeighting =
+                NZSlipRateConstraintWeightingType.BOTH; // (recommended: BOTH)
+
+        // weight of magnitude-distribution EQUALITY constraint relative to slip-rate
+        // constraint (recommended: 10)
+        // mfdEqualityConstraintWt = 10;
+
+        // weight of magnitude-distribution INEQUALITY constraint relative to slip-rate
+        // constraint (recommended: 1000)
+        // double mfdInequalityConstraintWt = 1000;
+
+        // magnitude-bin size for MFD participation smoothness constraint
+        //		double participationConstraintMagBinSize = 0.1;
+
+        // weight of rupture-rate smoothing constraint
+        //		double rupRateSmoothingConstraintWt = 0;
+
+        // weight of rupture-rate minimization constraint weights relative to slip-rate
+        // constraint (recommended: 10,000)
+        // (currently used to minimization rates of rups below sectMinMag)
+        double minimizationConstraintWt = 10000;
+
+        // weight of entropy-maximization constraint (should smooth rupture rates)
+        // (recommended: 10000)
+        //		double smoothnessWt = 0;
+
+        // weight of Moment Constraint (set solution moment to equal deformation model
+        // moment) (recommended: 1e-17)
+        //		double momentConstraintWt = 0;
+
+        // setup MFD constraints
+        NZSHM22_SubductionInversionTargetMFDs inversionMFDs =
+                new NZSHM22_SubductionInversionTargetMFDs(
+                        rupSet,
+                        totalRateM5,
+                        bValue,
+                        mfdTransitionMag,
+                        mfdMinMag,
+                        mfdUncertaintyWeightedConstraintWt,
+                        mfdUncertaintyWeightedConstraintPower,
+                        mfdUncertaintyWeightedConstraintScalar);
+        rupSet.setInversionTargetMFDs(inversionMFDs);
+
+        //		NZSHM22_SubductionInversionTargetMFDs inversionTargetMfds =
+        // (NZSHM22_SubductionInversionTargetMFDs) rupSet.getInversionTargetMFDs();
+
+        String metadata = "";
+
+        //		/* *******************************************
+        //		 * MODEL SPECIFIC
+        //		 * ******************************************* */
+        //		// define model specific value here (leave them as null or unassigned, then set values
+        //		// in the below switch statement
+        //
+        //		// weight of nucleation MFD constraint - applied on subsection basis
+        double nucleationMFDConstraintWt;
+        // fraction of the minimum rupture rate basis to be used as initial rates
+        double minimumRuptureRateFraction = 0;
+        double[] initialRupModel = null;
+        double[] minimumRuptureRateBasis = null;
+
+        @SuppressWarnings("unchecked")
+        List<IncrementalMagFreqDist> mfdConstraints = new ArrayList<>();
+        mfdConstraints.addAll(inversionMFDs.getMfdEqIneqConstraints());
+        mfdConstraints.addAll(inversionMFDs.getMfdUncertaintyConstraints());
+
+        //		SummedMagFreqDist targetOnFaultMFD =
+        // rupSet.getInversionTargetMFDs().getOnFaultSupraSeisMFD();
+        IncrementalMagFreqDist targetOnFaultMFD = inversionMFDs.getTotalOnFaultSupraSeisMFD();
+
+        if (model == InversionModels.CHAR_CONSTRAINED) {
+            nucleationMFDConstraintWt = 0.01;
+            // For water level
+            minimumRuptureRateFraction = 0.0;
+
+            // Made local copy of adjustStartingModel as it's private in
+            // UCERF3InversionConfiguration
+            minimumRuptureRateBasis =
+                    adjustStartingModel(
+                            UCERF3InversionConfiguration.getSmoothStartingSolution(
+                                    rupSet, targetOnFaultMFD),
+                            mfdConstraints,
+                            rupSet,
+                            true);
+
+            if (initialSolution != null) {
+                Preconditions.checkArgument(
+                        rupSet.getNumRuptures() == initialSolution.length,
+                        "Initial solution is for the wrong number of ruptures.");
+                initialRupModel = initialSolution;
+            } else {
+                initialRupModel = new double[rupSet.getNumRuptures()];
+            }
+        }
+
+        /* end MODIFIERS */
+
+        // NSHM-style config using setter methods...
+        NZSHM22_SubductionInversionConfiguration newConfig =
+                (NZSHM22_SubductionInversionConfiguration)
+                        new NZSHM22_SubductionInversionConfiguration()
+                                .setInversionTargetMfds(inversionMFDs)
+                                // MFD config is now below
+                                // Slip Rate config
+                                .setSlipRateConstraintWt_normalized(slipRateConstraintWt_normalized)
+                                .setSlipRateConstraintWt_unnormalized(
+                                        slipRateConstraintWt_unnormalized)
+                                .setSlipRateWeightingType(slipRateWeighting)
+                                // Rate Minimization config
+                                .setMinimizationConstraintWt(minimizationConstraintWt)
+                                .setMinimumRuptureRateFraction(minimumRuptureRateFraction)
+                                .setMinimumRuptureRateBasis(minimumRuptureRateBasis)
+                                .setInitialRupModel(initialRupModel);
+
+        // MFD constraint configuration
+        List<IncrementalMagFreqDist> mfdInequalityConstraints = new ArrayList<>();
+        List<IncrementalMagFreqDist> mfdEqualityConstraints = new ArrayList<>();
+        List<UncertainIncrMagFreqDist> mfdUncertaintyWeightedConstraints = new ArrayList<>();
+
+        mfdConstraints = inversionMFDs.getMfdEqIneqConstraints();
+        if (mfdEqualityConstraintWt > 0.0 && mfdInequalityConstraintWt > 0.0) {
+            // we have both MFD constraints, apply a transition mag from equality to
+            // inequality
+            mfdEqualityConstraints =
+                    MFDManipulation.restrictMFDConstraintMagRange(
+                            mfdConstraints, mfdConstraints.get(0).getMinX(), MFDTransitionMag);
+            mfdInequalityConstraints =
+                    MFDManipulation.restrictMFDConstraintMagRange(
+                            mfdConstraints, MFDTransitionMag, mfdConstraints.get(0).getMaxX());
+            newConfig
+                    .setMagnitudeEqualityConstraintWt(mfdEqualityConstraintWt)
+                    .setMagnitudeInequalityConstraintWt(mfdInequalityConstraintWt)
+                    .setMfdEqualityConstraints(mfdEqualityConstraints)
+                    .setMfdInequalityConstraints(mfdInequalityConstraints);
+        } else if (mfdEqualityConstraintWt > 0.0) { // no ineq wt
+            mfdEqualityConstraints = mfdConstraints;
+            newConfig
+                    .setMagnitudeEqualityConstraintWt(mfdEqualityConstraintWt)
+                    .setMfdEqualityConstraints(mfdEqualityConstraints);
+        } else if (mfdInequalityConstraintWt > 0.0) { // no eq wt
+            mfdInequalityConstraints = mfdConstraints;
+            newConfig
+                    .setMagnitudeInequalityConstraintWt(mfdInequalityConstraintWt)
+                    .setMfdInequalityConstraints(mfdInequalityConstraints);
+        }
+
+        if (mfdUncertaintyWeightedConstraintWt > 0.0) {
+            mfdUncertaintyWeightedConstraints = inversionMFDs.getMfdUncertaintyConstraints();
+            newConfig
+                    .setMagnitudeUncertaintyWeightedConstraintWt(
+                            mfdUncertaintyWeightedConstraintWt) // NEW constraint
+                    .setMfdUncertaintyWeightedConstraints(mfdUncertaintyWeightedConstraints);
+        }
+
+        return newConfig;
+    }
+
+    /**
+     * CBC: cloned this from UCERF3InversionConfiguration just for testing with some water levels.
+     * It needs work to decided a) if its wanted and b) how it should work!! @MCG
+     *
+     * <p>This method adjusts the starting model to ensure that for each MFD inequality constraint
+     * magnitude-bin, the starting model is below the MFD. If adjustOnlyIfOverMFD = false, it will
+     * adjust the starting model so that it's MFD equals the MFD constraint. It will uniformly
+     * reduce the rates of ruptures in any magnitude bins that need adjusting.
+     */
+    private static double[] adjustStartingModel(
+            double[] initialRupModel,
+            List<IncrementalMagFreqDist> mfdInequalityConstraints,
+            FaultSystemRupSet rupSet,
+            boolean adjustOnlyIfOverMFD) {
+
+        double[] rupMeanMag = rupSet.getMagForAllRups();
+
+        for (int i = 0; i < mfdInequalityConstraints.size(); i++) {
+            double[] fractRupsInside =
+                    rupSet.getFractRupsInsideRegion(
+                            mfdInequalityConstraints.get(i).getRegion(), false);
+            IncrementalMagFreqDist targetMagFreqDist = mfdInequalityConstraints.get(i);
+            IncrementalMagFreqDist startingModelMagFreqDist =
+                    new IncrementalMagFreqDist(
+                            targetMagFreqDist.getMinX(),
+                            targetMagFreqDist.size(),
+                            targetMagFreqDist.getDelta());
+            startingModelMagFreqDist.setTolerance(0.1);
+
+            // Find the starting model MFD
+            for (int rup = 0; rup < rupSet.getNumRuptures(); rup++) {
+                double mag = rupMeanMag[rup];
+                double fractRupInside = fractRupsInside[rup];
+                if (fractRupInside > 0)
+                    if (mag < 8.5) // b/c the mfdInequalityConstraints only go to M8.5!
+                    startingModelMagFreqDist.add(mag, fractRupInside * initialRupModel[rup]);
+            }
+
+            // Find the amount to adjust starting model MFD to be below or equal to Target MFD
+            IncrementalMagFreqDist adjustmentRatio =
+                    new IncrementalMagFreqDist(
+                            targetMagFreqDist.getMinX(),
+                            targetMagFreqDist.size(),
+                            targetMagFreqDist.getDelta());
+            for (double m = targetMagFreqDist.getMinX();
+                    m <= targetMagFreqDist.getMaxX();
+                    m += targetMagFreqDist.getDelta()) {
+                if (adjustOnlyIfOverMFD == false)
+                    adjustmentRatio.set(
+                            m,
+                            targetMagFreqDist.getClosestYtoX(m)
+                                    / startingModelMagFreqDist.getClosestYtoX(m));
+                else {
+                    if (startingModelMagFreqDist.getClosestYtoX(m)
+                            > targetMagFreqDist.getClosestYtoX(m))
+                        adjustmentRatio.set(
+                                m,
+                                targetMagFreqDist.getClosestYtoX(m)
+                                        / startingModelMagFreqDist.getClosestYtoX(m));
+                    else adjustmentRatio.set(m, 1.0);
+                }
+            }
+
+            // Adjust initial model rates
+            for (int rup = 0; rup < rupSet.getNumRuptures(); rup++) {
+                double mag = rupMeanMag[rup];
+                if (!Double.isNaN(adjustmentRatio.getClosestYtoX(mag))
+                        && !Double.isInfinite(adjustmentRatio.getClosestYtoX(mag)))
+                    initialRupModel[rup] =
+                            initialRupModel[rup] * adjustmentRatio.getClosestYtoX(mag);
+            }
+        }
+
+        /*		// OPTIONAL: Adjust rates of largest rups to equal global target MFD
+        IncrementalMagFreqDist targetMagFreqDist = UCERF3_MFD_ConstraintFetcher.getTargetMFDConstraint(TimeAndRegion.ALL_CA_1850).getMagFreqDist();
+        IncrementalMagFreqDist startingModelMagFreqDist = new IncrementalMagFreqDist(targetMagFreqDist.getMinX(), targetMagFreqDist.getNum(), targetMagFreqDist.getDelta());
+        startingModelMagFreqDist.setTolerance(0.1);
+        for(int rup=0; rup<rupSet.getNumRuptures(); rup++) {
+        	double mag = rupMeanMag[rup];
+        	if (mag<8.5)
+        		startingModelMagFreqDist.add(mag, initialRupModel[rup]);
+        }
+        IncrementalMagFreqDist adjustmentRatio = new IncrementalMagFreqDist(targetMagFreqDist.getMinX(), targetMagFreqDist.getNum(), targetMagFreqDist.getDelta());
+        for (double m=targetMagFreqDist.getMinX(); m<=targetMagFreqDist.getMaxX(); m+= targetMagFreqDist.getDelta()) {
+        	if (m>8.0)	adjustmentRatio.set(m, targetMagFreqDist.getClosestY(m) / startingModelMagFreqDist.getClosestY(m));
+        	else adjustmentRatio.set(m, 1.0);
+        }
+        for(int rup=0; rup<rupSet.getNumRuptures(); rup++) {
+        	double mag = rupMeanMag[rup];
+        	if (!Double.isNaN(adjustmentRatio.getClosestY(mag)) && !Double.isInfinite(adjustmentRatio.getClosestY(mag)))
+        		initialRupModel[rup] = initialRupModel[rup] * adjustmentRatio.getClosestY(mag);
+        }	*/
+
+        return initialRupModel;
+    }
+}
diff --git a/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/NZSHM22_SubductionInversionInputGenerator.java b/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/NZSHM22_SubductionInversionInputGenerator.java
index bc3ea0c..be75c6c 100644
--- a/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/NZSHM22_SubductionInversionInputGenerator.java
+++ b/src/main/java/nz/cri/gns/NZSHM22/opensha/inversion/NZSHM22_SubductionInversionInputGenerator.java
@@ -1,231 +1,231 @@
-package nz.cri.gns.NZSHM22.opensha.inversion;
-
-import com.google.common.base.Preconditions;
-import java.util.ArrayList;
-import java.util.List;
-import org.opensha.sha.earthquake.faultSysSolution.FaultSystemRupSet;
-import org.opensha.sha.earthquake.faultSysSolution.inversion.InversionInputGenerator;
-import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.ConstraintWeightingType;
-import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.InversionConstraint;
-import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.impl.MFDInversionConstraint;
-import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.impl.RupRateMinimizationConstraint;
-import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.impl.SlipRateInversionConstraint;
-
-/**
- * This class is used to generate inversion inputs (A/A_ineq matrices, d/d_ineq vectors) for a given
- * rupture set, inversion configuration, paleo rate constraints, improbability constraint, and paleo
- * probability model. It can also save these inputs to a zip file to be run on high performance
- * computing.
- */
-public class NZSHM22_SubductionInversionInputGenerator extends InversionInputGenerator {
-
-    private static final boolean D = false;
-    /**
-     * this enables use of the getQuick and setQuick methods on the sparse matrices. this comes with
-     * a performance boost, but disables range checks and is more prone to errors.
-     */
-    //	private static final boolean QUICK_GETS_SETS = true;
-
-    // inputs
-    //	private NZSHM22_InversionFaultSystemRuptSet rupSet;
-    private NZSHM22_SubductionInversionConfiguration config;
-    //	private List<AveSlipConstraint> aveSlipConstraints;
-    //	private double[] improbabilityConstraint;
-    //	private PaleoProbabilityModel paleoProbabilityModel;
-
-    public NZSHM22_SubductionInversionInputGenerator(
-            NZSHM22_InversionFaultSystemRuptSet rupSet,
-            NZSHM22_SubductionInversionConfiguration config
-            // , List<AveSlipConstraint> aveSlipConstraints
-            ) {
-        super(
-                rupSet,
-                buildConstraints(rupSet, config),
-                config.getInitialRupModel(),
-                buildWaterLevel(config, rupSet));
-        //		this.rupSet = rupSet;
-        this.config = config;
-        //		this.aveSlipConstraints = aveSlipConstraints;
-    }
-
-    private static List<InversionConstraint> buildConstraints(
-            NZSHM22_InversionFaultSystemRuptSet rupSet,
-            NZSHM22_SubductionInversionConfiguration config
-            // List<PaleoRateConstraint> paleoRateConstraints,
-            //			List<AveSlipConstraint> aveSlipConstraints
-            // PaleoProbabilityModel paleoProbabilityModel
-            ) {
-
-        System.out.println("buildConstraints");
-        System.out.println("================");
-
-        System.out.println(
-                "config.getSlipRateWeightingType(): " + config.getSlipRateWeightingType());
-        if (config.getSlipRateWeightingType()
-                == AbstractInversionConfiguration.NZSlipRateConstraintWeightingType
-                        .NORMALIZED_BY_UNCERTAINTY) {
-            System.out.println(
-                    "config.getSlipRateUncertaintyConstraintWt() :"
-                            + config.getSlipRateUncertaintyConstraintWt());
-            System.out.println(
-                    "config.getSlipRateUncertaintyConstraintScalingFactor() :"
-                            + config.getSlipRateUncertaintyConstraintScalingFactor());
-        } else {
-            System.out.println(
-                    "config.getSlipRateConstraintWt_normalized(): "
-                            + config.getSlipRateConstraintWt_normalized());
-            System.out.println(
-                    "config.getSlipRateConstraintWt_unnormalized(): "
-                            + config.getSlipRateConstraintWt_unnormalized());
-        }
-        System.out.println(
-                "config.getMinimizationConstraintWt(): " + config.getMinimizationConstraintWt());
-        System.out.println(
-                "config.getMagnitudeEqualityConstraintWt(): "
-                        + config.getMagnitudeEqualityConstraintWt());
-        System.out.println(
-                "config.getMagnitudeInequalityConstraintWt(): "
-                        + config.getMagnitudeInequalityConstraintWt());
-        System.out.println(
-                "config.getNucleationMFDConstraintWt():" + config.getNucleationMFDConstraintWt());
-
-        // builds constraint instances
-        List<InversionConstraint> constraints = new ArrayList<>();
-
-        // WARNING: pre-modular rupture sets have stdev 1000 times too large
-        if (config.getSlipRateWeightingType()
-                == AbstractInversionConfiguration.NZSlipRateConstraintWeightingType
-                        .NORMALIZED_BY_UNCERTAINTY) {
-            constraints.add(
-                    NZSHM22_SlipRateInversionConstraintBuilder.buildUncertaintyConstraint(
-                            config.getSlipRateUncertaintyConstraintWt(),
-                            rupSet,
-                            config.getSlipRateUncertaintyConstraintScalingFactor(),
-                            config.getUnmodifiedSlipRateStdvs()));
-        } else {
-            if (config.getSlipRateConstraintWt_normalized() > 0d
-                    && (config.getSlipRateWeightingType()
-                                    == AbstractInversionConfiguration
-                                            .NZSlipRateConstraintWeightingType.NORMALIZED
-                            || config.getSlipRateWeightingType()
-                                    == AbstractInversionConfiguration
-                                            .NZSlipRateConstraintWeightingType.BOTH)) {
-                constraints.add(
-                        new SlipRateInversionConstraint(
-                                config.getSlipRateConstraintWt_normalized(),
-                                ConstraintWeightingType.NORMALIZED,
-                                rupSet));
-            }
-
-            if (config.getSlipRateConstraintWt_unnormalized() > 0d
-                    && (config.getSlipRateWeightingType()
-                                    == AbstractInversionConfiguration
-                                            .NZSlipRateConstraintWeightingType.UNNORMALIZED
-                            || config.getSlipRateWeightingType()
-                                    == AbstractInversionConfiguration
-                                            .NZSlipRateConstraintWeightingType.BOTH)) {
-                constraints.add(
-                        new SlipRateInversionConstraint(
-                                config.getSlipRateConstraintWt_unnormalized(),
-                                ConstraintWeightingType.UNNORMALIZED,
-                                rupSet));
-            }
-        }
-
-        // Rupture rate minimization constraint
-        // Minimize the rates of ruptures below SectMinMag (strongly so that they have
-        // zero rates)
-        if (config.getMinimizationConstraintWt() > 0.0) {
-            List<Integer> belowMinIndexes = new ArrayList<>();
-            for (int r = 0; r < rupSet.getNumRuptures(); r++)
-                if (rupSet.isRuptureBelowSectMinMag(r)) belowMinIndexes.add(r);
-            constraints.add(
-                    new RupRateMinimizationConstraint(
-                            config.getMinimizationConstraintWt(), belowMinIndexes));
-        }
-
-        // Constrain Solution MFD to equal the Target MFD
-        // This is for equality constraints only -- inequality constraints must be
-        // encoded into the A_ineq matrix instead since they are nonlinear
-        if (config.getMagnitudeEqualityConstraintWt() > 0.0) {
-            constraints.add(
-                    new MFDInversionConstraint(
-                            rupSet,
-                            config.getMagnitudeEqualityConstraintWt(),
-                            false,
-                            config.getMfdEqualityConstraints()));
-        }
-
-        // Prepare MFD Inequality Constraint (not added to A matrix directly since it's
-        // nonlinear)
-        if (config.getMagnitudeInequalityConstraintWt() > 0.0)
-            // constraints.add(new MFDUncertaintyWeightedInversionConstraint(rupSet, 1000,
-            // mfdConstraints, null)
-            constraints.add(
-                    new MFDInversionConstraint(
-                            rupSet,
-                            config.getMagnitudeInequalityConstraintWt(),
-                            true,
-                            config.getMfdInequalityConstraints()));
-
-        // Prepare MFD Uncertainty Weighted Constraint
-        if (config.getMagnitudeUncertaintyWeightedConstraintWt() > 0.0)
-            constraints.add(
-                    new MFDInversionConstraint(
-                            rupSet,
-                            config.getMagnitudeUncertaintyWeightedConstraintWt(),
-                            false,
-                            ConstraintWeightingType.NORMALIZED_BY_UNCERTAINTY,
-                            config.getMfdUncertaintyWeightedConstraints()));
-
-        //		// MFD Subsection nucleation MFD constraint
-        //		ArrayList<SectionMFD_constraint> MFDConstraints = null;
-        //		if (config.getNucleationMFDConstraintWt() > 0.0) {
-        //			MFDConstraints =
-        // NZSHM22_FaultSystemRupSetCalc.getCharInversionSectMFD_Constraints(rupSet);
-        //			constraints.add(new MFDSubSectNuclInversionConstraint(rupSet,
-        // config.getNucleationMFDConstraintWt(),
-        //					MFDConstraints));
-        //		}
-
-        return constraints;
-    }
-
-    private static double[] buildWaterLevel(
-            NZSHM22_SubductionInversionConfiguration config, FaultSystemRupSet rupSet) {
-        double minimumRuptureRateFraction = config.getMinimumRuptureRateFraction();
-        if (minimumRuptureRateFraction > 0) {
-            // set up minimum rupture rates (water level)
-            double[] minimumRuptureRateBasis = config.getMinimumRuptureRateBasis();
-            Preconditions.checkNotNull(
-                    minimumRuptureRateBasis,
-                    "minimum rate fraction specified but no minimum rate basis given!");
-
-            // first check to make sure that they're not all zeros
-            boolean allZeros = true;
-            int numRuptures = rupSet.getNumRuptures();
-            for (int i = 0; i < numRuptures; i++) {
-                if (minimumRuptureRateBasis[i] > 0) {
-                    allZeros = false;
-                    break;
-                }
-            }
-            Preconditions.checkState(
-                    !allZeros, "cannot set water level when water level rates are all zero!");
-
-            double[] minimumRuptureRates = new double[numRuptures];
-            for (int i = 0; i < numRuptures; i++)
-                minimumRuptureRates[i] = minimumRuptureRateBasis[i] * minimumRuptureRateFraction;
-            return minimumRuptureRates;
-        }
-        return null;
-    }
-
-    public void generateInputs() {
-        generateInputs(null, D);
-    }
-
-    public NZSHM22_SubductionInversionConfiguration getConfig() {
-        return config;
-    }
-}
+package nz.cri.gns.NZSHM22.opensha.inversion;
+
+import com.google.common.base.Preconditions;
+import java.util.ArrayList;
+import java.util.List;
+import org.opensha.sha.earthquake.faultSysSolution.FaultSystemRupSet;
+import org.opensha.sha.earthquake.faultSysSolution.inversion.InversionInputGenerator;
+import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.ConstraintWeightingType;
+import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.InversionConstraint;
+import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.impl.MFDInversionConstraint;
+import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.impl.RupRateMinimizationConstraint;
+import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.impl.SlipRateInversionConstraint;
+
+/**
+ * This class is used to generate inversion inputs (A/A_ineq matrices, d/d_ineq vectors) for a given
+ * rupture set, inversion configuration, paleo rate constraints, improbability constraint, and paleo
+ * probability model. It can also save these inputs to a zip file to be run on high performance
+ * computing.
+ */
+public class NZSHM22_SubductionInversionInputGenerator extends InversionInputGenerator {
+
+    private static final boolean D = false;
+    /**
+     * this enables use of the getQuick and setQuick methods on the sparse matrices. this comes with
+     * a performance boost, but disables range checks and is more prone to errors.
+     */
+    //	private static final boolean QUICK_GETS_SETS = true;
+
+    // inputs
+    //	private NZSHM22_InversionFaultSystemRuptSet rupSet;
+    private NZSHM22_SubductionInversionConfiguration config;
+    //	private List<AveSlipConstraint> aveSlipConstraints;
+    //	private double[] improbabilityConstraint;
+    //	private PaleoProbabilityModel paleoProbabilityModel;
+
+    public NZSHM22_SubductionInversionInputGenerator(
+            NZSHM22_InversionFaultSystemRuptSet rupSet,
+            NZSHM22_SubductionInversionConfiguration config
+            // , List<AveSlipConstraint> aveSlipConstraints
+            ) {
+        super(
+                rupSet,
+                buildConstraints(rupSet, config),
+                config.getInitialRupModel(),
+                buildWaterLevel(config, rupSet));
+        //		this.rupSet = rupSet;
+        this.config = config;
+        //		this.aveSlipConstraints = aveSlipConstraints;
+    }
+
+    private static List<InversionConstraint> buildConstraints(
+            NZSHM22_InversionFaultSystemRuptSet rupSet,
+            NZSHM22_SubductionInversionConfiguration config
+            // List<PaleoRateConstraint> paleoRateConstraints,
+            //			List<AveSlipConstraint> aveSlipConstraints
+            // PaleoProbabilityModel paleoProbabilityModel
+            ) {
+
+        System.out.println("buildConstraints");
+        System.out.println("================");
+
+        System.out.println(
+                "config.getSlipRateWeightingType(): " + config.getSlipRateWeightingType());
+        if (config.getSlipRateWeightingType()
+                == AbstractInversionConfiguration.NZSlipRateConstraintWeightingType
+                        .NORMALIZED_BY_UNCERTAINTY) {
+            System.out.println(
+                    "config.getSlipRateUncertaintyConstraintWt() :"
+                            + config.getSlipRateUncertaintyConstraintWt());
+            System.out.println(
+                    "config.getSlipRateUncertaintyConstraintScalingFactor() :"
+                            + config.getSlipRateUncertaintyConstraintScalingFactor());
+        } else {
+            System.out.println(
+                    "config.getSlipRateConstraintWt_normalized(): "
+                            + config.getSlipRateConstraintWt_normalized());
+            System.out.println(
+                    "config.getSlipRateConstraintWt_unnormalized(): "
+                            + config.getSlipRateConstraintWt_unnormalized());
+        }
+        System.out.println(
+                "config.getMinimizationConstraintWt(): " + config.getMinimizationConstraintWt());
+        System.out.println(
+                "config.getMagnitudeEqualityConstraintWt(): "
+                        + config.getMagnitudeEqualityConstraintWt());
+        System.out.println(
+                "config.getMagnitudeInequalityConstraintWt(): "
+                        + config.getMagnitudeInequalityConstraintWt());
+        System.out.println(
+                "config.getNucleationMFDConstraintWt():" + config.getNucleationMFDConstraintWt());
+
+        // builds constraint instances
+        List<InversionConstraint> constraints = new ArrayList<>();
+
+        // WARNING: pre-modular rupture sets have stdev 1000 times too large
+        if (config.getSlipRateWeightingType()
+                == AbstractInversionConfiguration.NZSlipRateConstraintWeightingType
+                        .NORMALIZED_BY_UNCERTAINTY) {
+            constraints.add(
+                    NZSHM22_SlipRateInversionConstraintBuilder.buildUncertaintyConstraint(
+                            config.getSlipRateUncertaintyConstraintWt(),
+                            rupSet,
+                            config.getSlipRateUncertaintyConstraintScalingFactor(),
+                            config.getUnmodifiedSlipRateStdvs()));
+        } else {
+            if (config.getSlipRateConstraintWt_normalized() > 0d
+                    && (config.getSlipRateWeightingType()
+                                    == AbstractInversionConfiguration
+                                            .NZSlipRateConstraintWeightingType.NORMALIZED
+                            || config.getSlipRateWeightingType()
+                                    == AbstractInversionConfiguration
+                                            .NZSlipRateConstraintWeightingType.BOTH)) {
+                constraints.add(
+                        new SlipRateInversionConstraint(
+                                config.getSlipRateConstraintWt_normalized(),
+                                ConstraintWeightingType.NORMALIZED,
+                                rupSet));
+            }
+
+            if (config.getSlipRateConstraintWt_unnormalized() > 0d
+                    && (config.getSlipRateWeightingType()
+                                    == AbstractInversionConfiguration
+                                            .NZSlipRateConstraintWeightingType.UNNORMALIZED
+                            || config.getSlipRateWeightingType()
+                                    == AbstractInversionConfiguration
+                                            .NZSlipRateConstraintWeightingType.BOTH)) {
+                constraints.add(
+                        new SlipRateInversionConstraint(
+                                config.getSlipRateConstraintWt_unnormalized(),
+                                ConstraintWeightingType.UNNORMALIZED,
+                                rupSet));
+            }
+        }
+
+        // Rupture rate minimization constraint
+        // Minimize the rates of ruptures below SectMinMag (strongly so that they have
+        // zero rates)
+        if (config.getMinimizationConstraintWt() > 0.0) {
+            List<Integer> belowMinIndexes = new ArrayList<>();
+            for (int r = 0; r < rupSet.getNumRuptures(); r++)
+                if (rupSet.isRuptureBelowSectMinMag(r)) belowMinIndexes.add(r);
+            constraints.add(
+                    new RupRateMinimizationConstraint(
+                            config.getMinimizationConstraintWt(), belowMinIndexes));
+        }
+
+        // Constrain Solution MFD to equal the Target MFD
+        // This is for equality constraints only -- inequality constraints must be
+        // encoded into the A_ineq matrix instead since they are nonlinear
+        if (config.getMagnitudeEqualityConstraintWt() > 0.0) {
+            constraints.add(
+                    new MFDInversionConstraint(
+                            rupSet,
+                            config.getMagnitudeEqualityConstraintWt(),
+                            false,
+                            config.getMfdEqualityConstraints()));
+        }
+
+        // Prepare MFD Inequality Constraint (not added to A matrix directly since it's
+        // nonlinear)
+        if (config.getMagnitudeInequalityConstraintWt() > 0.0)
+            // constraints.add(new MFDUncertaintyWeightedInversionConstraint(rupSet, 1000,
+            // mfdConstraints, null)
+            constraints.add(
+                    new MFDInversionConstraint(
+                            rupSet,
+                            config.getMagnitudeInequalityConstraintWt(),
+                            true,
+                            config.getMfdInequalityConstraints()));
+
+        // Prepare MFD Uncertainty Weighted Constraint
+        if (config.getMagnitudeUncertaintyWeightedConstraintWt() > 0.0)
+            constraints.add(
+                    new MFDInversionConstraint(
+                            rupSet,
+                            config.getMagnitudeUncertaintyWeightedConstraintWt(),
+                            false,
+                            ConstraintWeightingType.NORMALIZED_BY_UNCERTAINTY,
+                            config.getMfdUncertaintyWeightedConstraints()));
+
+        //		// MFD Subsection nucleation MFD constraint
+        //		ArrayList<SectionMFD_constraint> MFDConstraints = null;
+        //		if (config.getNucleationMFDConstraintWt() > 0.0) {
+        //			MFDConstraints =
+        // NZSHM22_FaultSystemRupSetCalc.getCharInversionSectMFD_Constraints(rupSet);
+        //			constraints.add(new MFDSubSectNuclInversionConstraint(rupSet,
+        // config.getNucleationMFDConstraintWt(),
+        //					MFDConstraints));
+        //		}
+
+        return constraints;
+    }
+
+    private static double[] buildWaterLevel(
+            NZSHM22_SubductionInversionConfiguration config, FaultSystemRupSet rupSet) {
+        double minimumRuptureRateFraction = config.getMinimumRuptureRateFraction();
+        if (minimumRuptureRateFraction > 0) {
+            // set up minimum rupture rates (water level)
+            double[] minimumRuptureRateBasis = config.getMinimumRuptureRateBasis();
+            Preconditions.checkNotNull(
+                    minimumRuptureRateBasis,
+                    "minimum rate fraction specified but no minimum rate basis given!");
+
+            // first check to make sure that they're not all zeros
+            boolean allZeros = true;
+            int numRuptures = rupSet.getNumRuptures();
+            for (int i = 0; i < numRuptures; i++) {
+                if (minimumRuptureRateBasis[i] > 0) {
+                    allZeros = false;
+                    break;
+                }
+            }
+            Preconditions.checkState(
+                    !allZeros, "cannot set water level when water level rates are all zero!");
+
+            double[] minimumRuptureRates = new double[numRuptures];
+            for (int i = 0; i < numRuptures; i++)
+                minimumRuptureRates[i] = minimumRuptureRateBasis[i] * minimumRuptureRateFraction;
+            return minimumRuptureRates;
+        }
+        return null;
+    }
+
+    public void generateInputs() {
+        generateInputs(null, D);
+    }
+
+    public NZSHM22_SubductionInversionConfiguration getConfig() {
+        return config;
+    }
+}
